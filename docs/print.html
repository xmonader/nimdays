<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nim Days</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="book_intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li><a href="day01_dmidecode.html"><strong aria-hidden="true">2.</strong> Day 1 DMIDecode</a></li><li><a href="day02_bencode.html"><strong aria-hidden="true">3.</strong> Day 2: Parsing Bencode</a></li><li><a href="day03_libmagic.html"><strong aria-hidden="true">4.</strong> Day 3: FFI and Libmagic</a></li><li><a href="day04_asynclinkschecker.html"><strong aria-hidden="true">5.</strong> Day 4: Async LinksChecker</a></li><li><a href="day05_iniparser.html"><strong aria-hidden="true">6.</strong> Day 5: INI Parser</a></li><li><a href="day06_nistow.html"><strong aria-hidden="true">7.</strong> Day 6: Nistow (Dotfiles Manager)</a></li><li><a href="day07_shorturl.html"><strong aria-hidden="true">8.</strong> Day 7: URL Shortening Service</a></li><li><a href="day08_minitest.html"><strong aria-hidden="true">9.</strong> Day 8: MiniTest framework</a></li><li><a href="day09_tictactoe_cli.html"><strong aria-hidden="true">10.</strong> Day 9: TicTacToe CLI</a></li><li><a href="day10_tictactoe_gui.html"><strong aria-hidden="true">11.</strong> Day 10: TicTacToe GUI</a></li><li><a href="day11_buildsystem.html"><strong aria-hidden="true">12.</strong> Day 11: Bake build system</a></li><li><a href="day12_resp.html"><strong aria-hidden="true">13.</strong> Day 12: Redis Protocol</a></li><li><a href="day13_redisclient.html"><strong aria-hidden="true">14.</strong> Day 13: Redis Client</a></li><li><a href="day14_nimassets.html"><strong aria-hidden="true">15.</strong> Day 14: Nim-Assets</a></li><li><a href="day15_tcprouter.html"><strong aria-hidden="true">16.</strong> Day 15: TCP Router</a></li><li><a href="day16_asciitables.html"><strong aria-hidden="true">17.</strong> Day 16: AsciiTables</a></li><li><a href="day17_nimsonicclient.html"><strong aria-hidden="true">18.</strong> Day 17: Sonic-Client</a></li><li><a href="day18_webframework.html"><strong aria-hidden="true">19.</strong> Day 18: Webframework</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Nim Days</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#nim-days" id="nim-days"><h1>Nim Days</h1></a>
<p><a href="https://github.com/xmonader/nimdays">Nim days</a> book is about my journey using Nim and creating useful/practical things with it including:</p>
<ul>
<li>ini parser</li>
<li>bencode parser</li>
<li>links checker</li>
<li>tictactoe (commandline and gui)</li>
<li>testing framework</li>
<li>build system</li>
<li>tcp router</li>
<li>redis parser</li>
<li>redis client</li>
<li>assets bundler</li>
<li>terminal table</li>
<li>dotfiles manager</li>
<li>urlshortening application</li>
</ul>
<p>This book is influenced by the great books <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a>, <a href="http://book.realworldhaskell.org">Real World Haskell</a> and I'm planning to follow the same model of having the book available for free online.</p>
<a class="header" href="#reporting-issues" id="reporting-issues"><h1>Reporting issues</h1></a>
<p>You can report issues or create pull requests on the <a href="https://github.com/xmonader/nimdays">book repository</a></p>
<a class="header" href="#day-1-parsing-dmidecode-output" id="day-1-parsing-dmidecode-output"><h1>Day 1: Parsing DMIDecode output</h1></a>
<p>In our first day we will write a <a href="https://man.cx/?page=dmidecode(8)">dmidecode</a> parser in nim</p>
<a class="header" href="#what-to-expect-" id="what-to-expect-"><h2>What to expect ?</h2></a>
<pre><code class="language-Nimrod">let sample1 = &quot;&quot;&quot;
# dmidecode 3.1
Getting SMBIOS data from sysfs.
SMBIOS 2.6 present.

Handle 0x0001, DMI type 1, 27 bytes
System Information
        Manufacturer: LENOVO
        Product Name: 20042
        Version: Lenovo G560
        Serial Number: 2677240001087
        UUID: CB3E6A50-A77B-E011-88E9-B870F4165734
        Wake-up Type: Power Switch
        SKU Number: Calpella_CRB
        Family: Intel_Mobile
&quot;&quot;&quot;

import dmidecode, tables

var obj : Table[string, dmidecode.Section]
obj = parseDMI(sample)
for secname, sec in obj:
    echo secname &amp; &quot; with &quot; &amp; $len(sec.props)
    for k, p in sec.props:
        echo &quot;k : &quot; &amp; k &amp; &quot; =&gt; &quot; &amp; p.val 
        if len(p.items) &gt; 0:
            for i in p.items:
                echo &quot;\t\t I: &quot;, i

</code></pre>
<a class="header" href="#implementation" id="implementation"><h2>Implementation</h2></a>
<p>a while ago at work (https://github.com/zero-os/0-core) we needed to parse some dmidecode output, and it sounds like an good problem with enough concepts to get my feet wet in nim.</p>
<a class="header" href="#nimble-ready" id="nimble-ready"><h3>nimble ready!</h3></a>
<pre><code class="language-bash">mkdir dmidecode
nimble init
</code></pre>
<a class="header" href="#so-how-does-dmidecode-output-look-like" id="so-how-does-dmidecode-output-look-like"><h3>So how does dmidecode output look like?</h3></a>
<pre><code># dmidecode 3.1
Getting SMBIOS data from sysfs.
SMBIOS 2.6 present.

Handle 0x0001, DMI type 1, 27 bytes
System Information
        Manufacturer: LENOVO
        Product Name: 20042
        Version: Lenovo G560
        Serial Number: 2677240001087
        UUID: CB3E6A50-A77B-E011-88E9-B870F4165734
        Wake-up Type: Power Switch
        SKU Number: Calpella_CRB
        Family: Intel_Mobile
</code></pre>
<p>or</p>
<pre><code>Getting SMBIOS data from sysfs.
SMBIOS 2.6 present.

Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
        Vendor: LENOVO
        Version: 29CN40WW(V2.17)
        Release Date: 04/13/2011
        ROM Size: 2048 kB
        Characteristics:
                PCI is supported
                BIOS is upgradeable
                BIOS shadowing is allowed
                Boot from CD is supported
                Selectable boot is supported
                EDD is supported
                Japanese floppy for NEC 9800 1.2 MB is supported (int 13h)
                Japanese floppy for Toshiba 1.2 MB is supported (int 13h)
                5.25&quot;/360 kB floppy services are supported (int 13h)
                5.25&quot;/1.2 MB floppy services are supported (int 13h)
                3.5&quot;/720 kB floppy services are supported (int 13h)
                3.5&quot;/2.88 MB floppy services are supported (int 13h)
                8042 keyboard services are supported (int 9h)
                CGA/mono video services are supported (int 10h)
                ACPI is supported
                USB legacy is supported
                BIOS boot specification is supported
                Targeted content distribution is supported
        BIOS Revision: 1.40
</code></pre>
<ul>
<li>DMIDecode output is some meta like comments, versions and one or more sections</li>
<li>Section: consists of a
<ul>
<li>handle line</li>
<li>title line</li>
<li>one or more indented properties</li>
</ul>
</li>
<li>Property: consists of
<ul>
<li>key</li>
<li>optional value</li>
<li>optional list of indented items</li>
</ul>
</li>
</ul>
<a class="header" href="#mapping-dmi-to-nim-structures" id="mapping-dmi-to-nim-structures"><h3>Mapping DMI to nim structures</h3></a>
<p>So ourplan is to have an api like</p>
<pre><code class="language-Nimrod">dmifile = parseDMI(source)
dmifile[&quot;section1&quot;][&quot;property1].value
</code></pre>
<p>Let's describe the document structure we have</p>
<pre><code class="language-Nimrod">import  sequtils, tables, strutils

type 
    Property* = ref object
        val*: string
        items*: seq[string]
type
    Section* = ref object
        handleLine*, title*: string
        props* : Table[string, Property]

method addItem(this: Property, item: string) =
    this.items.add(item)

</code></pre>
<p>As our parsing will depend on the indentation level we can use this handy function to get the indentation level of a line (number of spaces before the first asciiLetter)</p>
<pre><code class="language-Nimrod">proc getIndentLevel(line: string) : int = 
    for i, c in pairs(line):
        if not c.isSpaceAscii():
            return i
    return 0
</code></pre>
<p>It'd have been nicer to use <code>takewhile</code>, but it's not available in nim stdlib</p>
<pre><code class="language-python">    getindentlevel = lambda l:  len(list(takewhile(lambda c: c.isspace(), l)))
</code></pre>
<a class="header" href="#parsing-dmi-source-into-nim-structures" id="parsing-dmi-source-into-nim-structures"><h3>Parsing DMI source into nim structures</h3></a>
<p>There're many ways to parse the DMI (e.g using regex which would be fairly simple &quot;feel free to implement it&quot; and kindly send me a PR to update this tutorial)</p>
<pre><code>proc parseDMI* (source: string) : Table[string, Section]=
</code></pre>
<p>In plain english for output like this</p>
<pre><code>Getting SMBIOS data from sysfs.
SMBIOS 2.6 present.

Handle 0x0000, DMI type 0, 24 bytes
BIOS Information
        Vendor: LENOVO
        Version: 29CN40WW(V2.17)
        Release Date: 04/13/2011
        ROM Size: 2048 kB
        Characteristics:
                PCI is supported
                BIOS is upgradeable
                BIOS shadowing is allowed
                Boot from CD is supported
                Selectable boot is supported
                EDD is supported
                Japanese floppy for NEC 9800 1.2 MB is supported (int 13h)
                Japanese floppy for Toshiba 1.2 MB is supported (int 13h)
                5.25&quot;/360 kB floppy services are supported (int 13h)
                5.25&quot;/1.2 MB floppy services are supported (int 13h)
                3.5&quot;/720 kB floppy services are supported (int 13h)
                3.5&quot;/2.88 MB floppy services are supported (int 13h)
                8042 keyboard services are supported (int 9h)
                CGA/mono video services are supported (int 10h)
                ACPI is supported
                USB legacy is supported
                BIOS boot specification is supported
                Targeted content distribution is supported
        BIOS Revision: 1.40
</code></pre>
<p>we have couple of states</p>
<pre><code class="language-Nimrod">type 
    ParserState = enum
        noOp, sectionName, readKeyValue, readList
</code></pre>
<ul>
<li>noOp: no action yet</li>
<li>sectionName: read sectionName</li>
<li>readKeyValue: read a line has colon <code>:</code> in it into a key value pair</li>
<li>readList: when the next line has greater indentation level than the property line</li>
</ul>
<p>so our state is noOp until we reach line
<code>Handle 0x0000, DMI type 0, 24 bytes</code>
then moves to sectionName</p>
<p>for line <code>BIOS Information</code> then state changes to reading properties</p>
<pre><code>        Vendor: LENOVO
        Version: 29CN40WW(V2.17)
        Release Date: 04/13/2011
        ROM Size: 2048 kB
        Characteristics:
</code></pre>
<p>then we notice the indentation on the next line is greater than the one on the current line</p>
<pre><code>                PCI is supported
        Characteristics:
</code></pre>
<p>so state moves into readList to read the items related to property <code>Characterstics</code></p>
<pre><code>                PCI is supported
                BIOS is upgradeable
                BIOS shadowing is allowed
                Boot from CD is supported
                Selectable boot is supported
                EDD is supported
                Japanese floppy for NEC 9800 1.2 MB is supported (int 13h)
                Japanese floppy for Toshiba 1.2 MB is supported (int 13h)
                5.25&quot;/360 kB floppy services are supported (int 13h)
                5.25&quot;/1.2 MB floppy services are supported (int 13h)
                3.5&quot;/720 kB floppy services are supported (int 13h)
                3.5&quot;/2.88 MB floppy services are supported (int 13h)
                8042 keyboard services are supported (int 9h)
                CGA/mono video services are supported (int 10h)
                ACPI is supported
                USB legacy is supported
                BIOS boot specification is supported
                Targeted content distribution is supported
</code></pre>
<p>and again it notices the indentation is of the next line is less than the current line</p>
<pre><code>        BIOS Revision: 1.40
                Targeted content distribution is supported
</code></pre>
<p>so state switches again into <code>readKeyValue</code></p>
<ul>
<li>if we encounter an empty line:
<ul>
<li>if not in parsing state then it's a noOp we ignore meta and empty lines</li>
<li>if in parsing state <code>current Section isn't nil</code> we finish parsing the section object</li>
</ul>
</li>
</ul>
<pre><code class="language-Nimrod">
proc parseDMI* (source: string) : Table[string, Section]=
    
    var
        state : ParserState = noOp
        lines = strutils.splitLines(source)
        sects = initTable[string, Section]()
        
        p: Property = nil
        s: Section = nil 
        k, v: string
</code></pre>
<p>Here we define the current state, code lines, initialize a table <code>sects</code> from <code>sectionName</code> to <code>Section Object</code> and variables p <code>current property</code>, s <code>current section</code>, k, v <code>current property key, value</code></p>
<pre><code class="language-Nimrod">    for i, l in pairs(lines):
</code></pre>
<p>Start looping on index, line using <code>pairs</code></p>
<blockquote>
<p>pairs is kinda like enumerate in python</p>
</blockquote>
<pre><code class="language-Nimrod">        if l.startsWith(&quot;Handle&quot;):
            s = new Section
            s.props = initTable[string, Property]()
            s.handleline = l
            state = sectionName
            continue 
</code></pre>
<p>If we encounter the string <code>Handle</code></p>
<ul>
<li>create new section object and initialize it's props table</li>
<li>keep track of the handle line</li>
<li>switch state to reading sectionName</li>
<li>continue the loop to move to the title line</li>
</ul>
<pre><code class="language-Nimrod">        if l == &quot;&quot;: # can be just new line before reading any sections. 
            if s != nil:
                sects[s.title] = s
            continue
</code></pre>
<p>if line is empty and we have a section object <code>not nil</code> we finish the section and continue</p>
<pre><code class="language-Nimrod">        if state == sectionName:  # current line is the title line
            s.title = l
            state = readKeyValue  # change state into reading key value pairs
</code></pre>
<p>If state is sectionName:</p>
<ul>
<li>this line is a title line</li>
<li>change state for the upcoming to readKeyValue</li>
</ul>
<pre><code class="language-Nimrod">        elif state == readKeyValue:
            let pair = l.split({':'})
            k = pair[0].strip()
            if len(pair) == 2:
                v = pair[1].strip()
            else:                 # value can be empty
                v = &quot;&quot;
            p = Property(val: v)
            p.items = newSeq[string]()
            p.val = v
</code></pre>
<p>If state is readKeyValue</p>
<ul>
<li>split the line on colon <code>:</code> to get key, value pair and set v to &quot;&quot; if not present</li>
<li>make current Property <code>p</code> and initialize its related fields <code>items</code>, <code>val</code></li>
</ul>
<pre><code class="language-Nimrod">            # current line indentation is &lt;  nextline indentation =&gt; change state to readList
            if i &lt; len(lines) and (getIndentlevel(l) &lt; getIndentlevel(lines[i+1])) :
                state = readList
</code></pre>
<p>If the next line indentation is greater this means we're should be reading list of items regarding the current property <code>p</code></p>
<pre><code class="language-Nimrod">            else:
                # add key/value pair directly
                s.props[k] = p
</code></pre>
<p>If not finish the property</p>
<pre><code class="language-Nimrod">        elif state == readList:
            # keep adding the current line to current property items and if dedented =&gt; change state to readKeyValue
            p.add_item(l.strip())
            if getindentlevel(l) &gt; getindentlevel(lines[i+1]):
                state = readKeyValue 
                s.props[k] = p
</code></pre>
<p>if state is <code>readList</code></p>
<ul>
<li>keep adding items to current property <code>p</code></li>
<li>if the indentation level decreased change state to <code>readKeyValue</code> and finish property</li>
</ul>
<pre><code>    return sects

</code></pre>
<a class="header" href="#day-2-parsing-bencode" id="day-2-parsing-bencode"><h1>Day 2: Parsing Bencode</h1></a>
<p>nim-bencode is a library to encode/decode torrent files <a href="https://en.wikipedia.org/wiki/Bencode">Bencode</a></p>
<a class="header" href="#what-to-expect" id="what-to-expect"><h2>What to expect?</h2></a>
<pre><code class="language-Nimrod">import bencode, tables, strformat

let encoder = newEncoder()
let decoder = newDecoder()

let btListSample1 = @[BencodeType(kind:btInt, i:1), BencodeType(kind:btString, s:&quot;hi&quot;) ]
var btDictSample1 = initOrderedTable[BencodeType, BencodeType]()
btDictSample1[BencodeType(kind:btString, s:&quot;name&quot;)] = BencodeType(kind:btString, s:&quot;dmdm&quot;)
btDictSample1[BencodeType(kind:btString, s:&quot;lang&quot;)] = BencodeType(kind:btString, s:&quot;nim&quot;)
btDictSample1[BencodeType(kind:btString, s:&quot;age&quot;)] = BencodeType(kind:btInt, i:50)
btDictSample1[BencodeType(kind:btString, s:&quot;alist&quot;)] = BencodeType(kind:btList, l:btListSample1)

var testObjects = initOrderedTable[BencodeType, string]()
testObjects[BencodeType(kind: btString, s:&quot;hello&quot;)] = &quot;5:hello&quot;
testObjects[BencodeType(kind: btString, s:&quot;yes&quot;)] = &quot;3:yes&quot;
testObjects[BencodeType(kind: btInt, i:55)] = &quot;i55e&quot;

testObjects[BencodeType(kind: btInt, i:12345)] = &quot;i12345e&quot;
testObjects[BencodeType(kind: btList, l:btListSample1)] = &quot;li1e2:hie&quot;
testObjects[BencodeType(kind:btDict, d:btDictSample1)] = &quot;d4:name4:dmdm4:lang3:nim3:agei50e5:alistli1e2:hiee&quot;


for k, v in testObjects.pairs():
    echo $k &amp; &quot; =&gt; &quot; &amp; $v
    doAssert(encoder.encodeObject(k) == v)
    doAssert(decoder.decodeObject(v) == k)

</code></pre>
<a class="header" href="#implementation-1" id="implementation-1"><h2>Implementation</h2></a>
<p>So according to Bencode we have some datatypes</p>
<ul>
<li>strings and those are encoded with the string length followed by a colon and the string itself <code>length:string</code>, e.g yes will be encoded into <code>3:yes</code></li>
<li>ints those are encoded between <code>i</code>, <code>e</code> letters, e.g 59 will be encoded into <code>i59e</code></li>
<li>lists can contain any of the bencode types and it's encoded with <code>l</code>, <code>e</code>,  e.g list of 1, 2 numbers is encoded into <code>li1ei2e</code> or with spaces for verbosity <code>l i1e i2e e</code></li>
<li>dicts are mapping from strings to any type and encoded between letters <code>d</code>, <code>e</code>, e.g name =&gt; hi and num =&gt; 3 is encoded into <code>d4:name2:hi3:numi3ee</code> or with spaces for verbosity <code>d 4:name 2:hi 3:num i3e e</code></li>
</ul>
<a class="header" href="#imports" id="imports"><h3>Imports</h3></a>
<pre><code class="language-Nimrod">import strformat, tables, json, strutils, hashes
</code></pre>
<p>As we will be dealing a lot with strings, tables</p>
<a class="header" href="#types" id="types"><h3>Types</h3></a>
<pre><code class="language-Nimrod">type 
    BencodeKind* = enum
        btString, btInt, btList, btDict
</code></pre>
<p>So as we mentioned about bencode data types we can define an enum to represents the kinds</p>
<pre><code class="language-Nimrod">    BencodeType* = ref object
        case kind*: BencodeKind 
        of BencodeKind.btString: s* : string 
        of BencodeKind.btInt: i*    : int
        of BencodeKind.btList: l*   : seq[BencodeType]
        of BencodeKind.btDict: d*  : OrderedTable[BencodeType, BencodeType]

    Encoder* = ref object
    Decoder* = ref object 
</code></pre>
<ul>
<li><code>Encoder</code> a simple class to represent encoding operations</li>
<li><code>Decoder</code> a simple class to represent decoding operations</li>
<li>For <code>BencodeType</code> we make use of variant objects <code>case classes</code> in other languages. worth noticing variant objects are the same technique used for <code>json</code> module.</li>
</ul>
<p>So we can use it like this</p>
<pre><code class="language-Nimrod">BencodeType(kind: btString, s:&quot;hello&quot;)
BencodeType(kind: btInt, i:55)
let btListSample1 = @[BencodeType(kind:btInt, i:1), BencodeType(kind:btString, s:&quot;hi&quot;) ]
BencodeType(kind: btList, l:btListSample1)
</code></pre>
<p>So general rule for the case classes is you have a kind defined in an enum and a constructor value u create the object with.</p>
<p>If you're coming from Haskell or a similar language</p>
<pre><code class="language-haskell">data BValue = BInt Integer
            | BStr B.ByteString
            | BList [BValue]
            | BDict (M.Map BValue BValue)
            deriving (Show, Eq, Ord)
</code></pre>
<p>Please, note if you define your own variant you should define <code>hash</code>, <code>==</code> procs to be able to compare or hash the values.</p>
<pre><code class="language-Nimrod">proc hash*(obj: BencodeType): Hash = 
    case obj.kind
    of btString : !$(hash(obj.s))
    of btInt : !$(hash(obj.i))
    of btList: !$(hash(obj.l))
    of btDict: 
        var h = 0
        for k, v in obj.d.pairs:
            h = hash(k) !&amp; hash(v)
        !$(h)
</code></pre>
<ul>
<li><code>hash</code> proc returns <code>Hash</code>  and depending on the <code>kind</code> we return the hash of the underlying stored objects, strings, ints, lists or calculate a new hash if needed</li>
<li><code>!&amp;</code> consider it like merging the two hashes together</li>
<li><code>!$</code> is used to finalize the Hash object</li>
</ul>
<pre><code class="language-Nimrod">proc `==`* (a, b: BencodeType): bool =
    ## Check two nodes for equality
    if a.isNil:
        if b.isNil: return true
        return false
    elif b.isNil or a.kind != b.kind:
        return false
    else:
        case a.kind
        of btString:
            result = a.s == b.s
        of btInt:
            result = a.i == b.i
        of btList:
            result = a.l == b.l
        of btDict:
            if a.d.len != b.d.len: return false
            for key, val in a.d:
                if not b.d.hasKey(key): return false
                if b.d[key] != val: return false
            result = true
</code></pre>
<p>define equality operator on BencodeTypes to determine when they're equal by defining proc for operator <code>==</code></p>
<pre><code class="language-Nimrod">proc `$`* (a: BencodeType): string = 
    case a.kind
    of btString:  fmt(&quot;&lt;Bencode {a.s}&gt;&quot;)
    of btInt: fmt(&quot;&lt;Bencode {a.i}&gt;&quot;)
    of btList: fmt(&quot;&lt;Bencode {a.l}&gt;&quot;)
    of btDict: fmt(&quot;&lt;Bencode {a.d}&quot;)
</code></pre>
<p>Define a simple <code>toString</code> proc using the <code>$</code> operator.</p>
<a class="header" href="#encoding" id="encoding"><h3>Encoding</h3></a>
<pre><code class="language-Nimrod">proc encode(this: Encoder,  obj: BencodeType) : string
</code></pre>
<p>we add forward declarating to encode proc because to encode a list we might encode another values <code>strings</code>, or even <code>lists</code> so we will recursively call encode if needed, feel free to skip to the next part.</p>
<pre><code class="language-Nimrod">proc encode_s(this: Encoder, s: string) : string=
    # TODO: check len
    return $s.len &amp; &quot;:&quot; &amp; s
</code></pre>
<p>To encode a string we said we will put encoded with its length + <code>:</code> + string itself</p>
<pre><code class="language-Nimrod">proc encode_i(this: Encoder, i: int) : string=
    # TODO: check len
    return fmt(&quot;i{i}e&quot;) 
</code></pre>
<p>To encode an int we put it between <code>i</code>, <code>e</code> chars</p>
<pre><code class="language-Nimrod">proc encode_l(this: Encoder, l: seq[BencodeType]): string =
    var encoded = &quot;l&quot;
    for el in l:
        encoded &amp;= this.encode(el)
    encoded &amp;= &quot;e&quot;
    return encoded
</code></pre>
<ul>
<li>To encode a list of elements of type <code>BencodeType</code> we put their encoded values between <code>l</code>, <code>e</code> chars</li>
<li>Notice the call to <code>this.encode</code> that's why we needed the forward declaration.</li>
</ul>
<pre><code class="language-Nimrod">proc encode_d(this: Encoder, d: OrderedTable[BencodeType, BencodeType]): string =
    var encoded = &quot;d&quot;
    for k, v in d.pairs():
        assert k.kind == BencodeKind.btString
        encoded &amp;= this.encode(k) &amp; this.encode(v)

    encoded &amp;= &quot;e&quot;
    return encoded
</code></pre>
<ul>
<li>To encode a dict we enclose the encoded value of the pairs between <code>d</code>, <code>e</code></li>
<li>Notice the recursive call to <code>this.encode</code> to the keys and values</li>
<li>Notice the assertion the kind of the keys <code>must</code> be a <code>btString</code> according to <code>Bencode</code> specs.</li>
</ul>
<pre><code class="language-Nimrod">proc encode(this: Encoder,  obj: BencodeType) :  string =
    case obj.kind
    of BencodeKind.btString:  result =this.encode_s(obj.s)
    of BencodeKind.btInt :  result = this.encode_i(obj.i)
    of BencodeKind.btList : result = this.encode_l(obj.l)
    of BencodeKind.btDict : result = this.encode_d(obj.d)
</code></pre>
<p>Simple proxy to encode <code>obj</code> of <code>BencodeType</code></p>
<a class="header" href="#decoding" id="decoding"><h3>Decoding</h3></a>
<pre><code class="language-Nimrod">proc decode(this: Decoder,  source: string) : (BencodeType, int)
</code></pre>
<p>Forward declaration for <code>decode</code> same as <code>decode</code></p>
<pre><code class="language-Nimrod">proc decode_s(this: Decoder, s: string) : (BencodeType, int) =
    let lengthpart = s.split(&quot;:&quot;)[0]
    let sizelength = lengthpart.len
    let strlen = parseInt(lengthpart)
    return (BencodeType(kind:btString, s: s[sizelength+1..strlen+1]), sizelength+1+strlen)
</code></pre>
<p>Create a BencodeType of after decoding a string <code>reverse operation of encode_s</code>
Basically and read string of length <code>sizelength</code> after the <code>colon</code> and construct a <code>BencodeType</code> of kind <code>btString</code> out of it</p>
<pre><code class="language-Nimrod">proc decode_i(this: Decoder, s: string) : (BencodeType, int) =
    let epos = s.find('e')
    let i = parseInt(s[1..&lt;epos])
    return (BencodeType(kind:btInt, i:i), epos+1)

</code></pre>
<p>Extract the number between <code>i</code>, <code>e</code> chars and construct <code>BencodeType</code> of kind <code>btInt</code> out of it</p>
<pre><code class="language-Nimrod">proc decode_l(this: Decoder, s: string): (BencodeType, int) =
    # l ... e
    var els = newSeq[BencodeType]()
    var curchar = s[1]
    var idx = 1
    while idx &lt; s.len:
        curchar = s[idx]
        if curchar == 'e':
            idx += 1
            break
    
        let pair = this.decode(s[idx..&lt;s.len])
        let obj = pair[0]
        let nextobjpos = pair[1] 
        els.add(obj)
        idx += nextobjpos
    return (BencodeType(kind:btList, l:els), idx)
</code></pre>
<p>Decoding the list can be bit tricky</p>
<ul>
<li>Its elements are between <code>l</code>, <code>e</code> chars</li>
<li>So we start trying to decode objects starting from the first letter <code>after</code> the <code>l</code> until we reach the final <code>e</code>
e.g</li>
</ul>
<pre><code>li1ei2ee
</code></pre>
<p>will be parsed like the following</p>
<pre><code>li120ei492ee
 $   $
</code></pre>
<ul>
<li>will consume the object <code>i120e</code> and set the cursor to the beginning of the second object <code>i492e</code></li>
<li>after all the objects are consumed we consume the end character <code>e</code> and we are done</li>
<li>That's why all decode procs return <code>int</code> value to let us now how much characters to skip</li>
</ul>
<pre><code class="language-Nimrod">proc decode_d(this: Decoder, s: string): (BencodeType, int) =
    var d = initOrderedTable[BencodeType, BencodeType]()
    var curchar = s[1]
    var idx = 1
    var readingKey = true
    var curKey: BencodeType
    while idx &lt; s.len:
        curchar = s[idx]
        if curchar == 'e':
            break
        let pair = this.decode(s[idx..&lt;s.len])
        let obj = pair[0]
        let nextobjpos = pair[1]
        if readingKey == true:
            curKey = obj
            readingKey = false
        else:
            d[curKey] = obj
            readingKey = true
        idx += nextobjpos
    return (BencodeType(kind:btDict, d: d), idx)
</code></pre>
<ul>
<li>Same technique as above</li>
<li>Basically we read one object if we don't have a current key then we set it as the current key</li>
<li>If we have a current key object then the object we read is the value, so we set the currentKey to that value and <code>change</code> mode to readingKey again.</li>
</ul>
<pre><code class="language-Nimrod">proc decode(this: Decoder,  source: string) : (BencodeType, int) =
    var curchar = source[0]
    var idx = 0
    while idx &lt; source.len:
        curchar = source[idx]
        case curchar
        of 'i':
            let pair = this.decode_i(source[idx..source.len])
            let obj = pair[0]
            let nextobjpos = pair[1] 
            idx += nextobjpos
            return (obj, idx)
        of 'l':
            let pair = this.decode_l(source[idx..source.len])
            let obj = pair[0]
            let nextobjpos = pair[1] 
            idx += nextobjpos
            return (obj, idx)
        of 'd':
            let pair = this.decode_d(source[idx..source.len])
            let obj = pair[0]
            let nextobjpos = pair[1] 
            idx += nextobjpos
            return (obj, idx)
        else: 
            let pair = this.decode_s(source[idx..source.len])
            let obj = pair[0]
            let nextobjpos = pair[1] 
            idx += nextobjpos
            return (obj, idx)
</code></pre>
<p>Starts decoding based on the beginning of character encoding object <code>i</code> for int, <code>l</code> for lists, <code>d</code> for dicts and otherwise tries to parse string</p>
<pre><code class="language-Nimrod">proc newEncoder*(): Encoder =
    new Encoder

proc newDecoder*(): Decoder = 
    new Decoder
</code></pre>
<p>Simple constructor procs for newEncoder, newDecoder</p>
<pre><code class="language-Nimrod">proc encodeObject*(this: Encoder, obj: BencodeType) : string =
    return this.encode(obj)
</code></pre>
<p><code>encodeObject</code> dispatch the call to <code>encode</code> proc.</p>
<pre><code class="language-Nimrod">proc decodeObject*(this: Decoder, source:string) : BencodeType =
    let p = this.decode(source)
    return p[0]
</code></pre>
<p><code>decodeObject</code> provides a friendlier API to return the BencodeType from decode instead of <code>BencodeType</code>, <code>how many to read</code> int</p>
<a class="header" href="#day-3-talking-to-c-ffi-and-libmagic" id="day-3-talking-to-c-ffi-and-libmagic"><h1>Day 3: Talking to C (FFI and libmagic)</h1></a>
<p>Libmagic is a magic number recognition library, remember everytime you called <code>file</code> utility on a file to know its type?</p>
<pre><code>➜  file /usr/bin/rm
/usr/bin/rm: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=cbae26b2a032b1ce3129d56aee2bcf70dd8deeb0, stripped
➜  nim-magic file /
/: directory
➜  file /usr/include/stdio.h
/usr/include/stdio.h: C source, ASCII text
</code></pre>
<a class="header" href="#what-to-expect-1" id="what-to-expect-1"><h2>What to expect?</h2></a>
<pre><code class="language-Nimrod">import magic

echo magic.guessFile(&quot;/usr/bin/rm&quot;)
</code></pre>
<p>The output should be something like</p>
<pre><code>ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=cbae26b2a032b1ce3129d56aee2bcf70dd8deeb0, stripped
</code></pre>
<a class="header" href="#implementation-2" id="implementation-2"><h2>Implementation</h2></a>
<p><a href="https://livebook.manning.com/#!/book/nim-in-action/chapter-8/1">FFI Chapter</a> of <a href="https://www.manning.com/books/nim-in-action">Nim in Action</a> is freely available.</p>
<a class="header" href="#step-1-get-the-library-info" id="step-1-get-the-library-info"><h3>Step 1: Get the library info</h3></a>
<p>Well, libmagic has <code>libmagic.so</code> in your library path <code>/usr/lib/libmagic.so</code> and a header file <code>magic.h</code> in <code>/usr/include/magic.h</code>.
create a constant for the libmagic library name.</p>
<pre><code class="language-Nimrod">const libName* = &quot;libmagic.so&quot;
</code></pre>
<a class="header" href="#step-2-extract-constants" id="step-2-extract-constants"><h3>Step 2: Extract constants</h3></a>
<p>We should extract the constants from the header</p>
<pre><code class="language-c">#define MAGIC_NONE              0x0000000 /* No flags */
#define MAGIC_DEBUG             0x0000001 /* Turn on debugging */
#define MAGIC_SYMLINK           0x0000002 /* Follow symlinks */
#define MAGIC_COMPRESS          0x0000004 /* Check inside compressed files */
#define MAGIC_DEVICES           0x0000008 /* Look at the contents of devices */
#define MAGIC_MIME_TYPE         0x0000010 /* Return the MIME type */
#define MAGIC_CONTINUE          0x0000020 /* Return all matches */
#define MAGIC_CHECK             0x0000040 /* Print warnings to stderr */
....

</code></pre>
<p>So in nim It'd be something like this</p>
<pre><code class="language-Nimrod">const  MAGIC_NONE*  = 0x000000                 # No flags 
const  MAGIC_DEBUG* = 0x000001                 # Turn on debugging 
const  MAGIC_SYMLINK* = 0x000002                 # Follow symlinks 
const  MAGIC_COMPRESS* = 0x000004                # Check inside compressed files 
const  MAGIC_DEVICES* = 0x000008                 # Look at the contents of devices 
const  MAGIC_MIME_TYPE* = 0x000010            # Return only the MIME type 
const  MAGIC_CONTINUE* = 0x000020             # Return all matches 
const  MAGIC_CHECK* = 0x000040                 # Print warnings to stderr 
const  MAGIC_PRESERVE_ATIME* = 0x000080        # Restore access time on exit 
const  MAGIC_RAW* = 0x000100                    # Don't translate unprint chars 
const  MAGIC_ERROR* = 0x000200                 # Handle ENOENT etc as real errors 
const  MAGIC_MIME_ENCODING* = 0x000400         # Return only the MIME encoding 
const  MAGIC_NO_CHECK_COMPRESS* = 0x001000     # Don't check for compressed files 
const  MAGIC_NO_CHECK_TAR* = 0x002000         # Don't check for tar files 
const  MAGIC_NO_CHECK_SOFT* = 0x004000         # Don't check magic entries 
const  MAGIC_NO_CHECK_APPTYPE* = 0x008000        # Don't check application type 
const  MAGIC_NO_CHECK_ELF* = 0x010000            # Don't check for elf details 
const  MAGIC_NO_CHECK_ASCII* = 0x020000         # Don't check for ascii files 
const  MAGIC_NO_CHECK_TOKENS* = 0x100000         # Don't check ascii/tokens 
</code></pre>
<a class="header" href="#step-3-extract-the-types" id="step-3-extract-the-types"><h3>Step 3: Extract the types</h3></a>
<p><code>typedef struct magic_set *magic_t;</code>
so the only type we have is a pointer to some struct (object)</p>
<pre><code class="language-Nimrod">type Magic = object
type MagicPtr* = ptr Magic 
</code></pre>
<a class="header" href="#step-4-extract-procedures" id="step-4-extract-procedures"><h3>Step 4: Extract procedures</h3></a>
<pre><code class="language-c">magic_t magic_open(int);
void magic_close(magic_t);

const char *magic_getpath(const char *, int);
const char *magic_file(magic_t, const char *);
const char *magic_descriptor(magic_t, int);
const char *magic_buffer(magic_t, const void *, size_t);

const char *magic_error(magic_t);
int magic_getflags(magic_t);
int magic_setflags(magic_t, int);

int magic_version(void);
int magic_load(magic_t, const char *);
int magic_load_buffers(magic_t, void **, size_t *, size_t);

int magic_compile(magic_t, const char *);
int magic_check(magic_t, const char *);
int magic_list(magic_t, const char *);
int magic_errno(magic_t);
</code></pre>
<p>we only care about <code>magic_open</code>, <code>magic_load</code>, <code>magic_close</code>, <code>magic_file</code>, <code>magic_error</code></p>
<pre><code class="language-Nimrod"># magic_t magic_open(int);
proc magic_open(i:cint) : MagicPtr {.importc, dynlib:libName.}
</code></pre>
<p><code>magic_open</code> is a proc declared in dynamic lib <code>libmagic.so</code>, that is takes a cint &quot;compatible c int&quot; <code>i</code> and returns a <code>MagicPtr</code>.</p>
<p>From the manpage</p>
<blockquote>
<p>The function magic_open() creates a magic cookie pointer and returns it.  It returns NULL if there was an error allocating the magic cookie.  The flags argument specifies how the other magic functions should behave</p>
</blockquote>
<pre><code class="language-Nimrod"># void magic_close(magic_t);
proc magic_close(p:MagicPtr): void {.importc,  dynlib:libName.}
</code></pre>
<p><code>magic_close</code> is a proc declared in dynlib <code>libmagic.so</code> and takes an argumnet p of type <code>MagicPtr</code> and returns <code>void</code></p>
<p>From the manpage</p>
<blockquote>
<p>The magic_close() function closes the magic(5) database and deallocates any resources used.</p>
</blockquote>
<pre><code class="language-Nimrod">#int magic_load(magic_t, const char *);
proc magic_load(p:MagicPtr, s:cstring) : cint {.importc, dynlib: libName.}
</code></pre>
<p><code>magic_load</code> is a proc declared in dynlib <code>libmagic.so</code> takes argument p of type <code>MagicPtr</code> and a <code>cstring</code> &quot;compatible c string&quot; <code>s</code> and returns a <code>cint</code></p>
<p>From manpage:</p>
<blockquote>
<p>The magic_load() function must be used to load the colon separated list of database files passed in as filename, or NULL for the default database
file before any magic queries can performed.</p>
</blockquote>
<pre><code class="language-Nimrod">#int magic_errno(magic_t);
proc magic_error(p: MagicPtr) : cstring  {.importc, dynlib:libName.}
</code></pre>
<p><code>magic_errno</code> is a proc declared in dynlib <code>libmagic.so</code> and takes argument p of type <code>MagicPtr</code> and returns a <code>cstring</code></p>
<p>From manpage</p>
<blockquote>
<p>The magic_error() function returns a textual explanation of the last error, or NULL if there was no error.</p>
</blockquote>
<pre><code class="language-Nimrod">#const char *magic_file(magic_t, const char *);
proc magic_file(p:MagicPtr, filepath: cstring): cstring {.importc, dynlib: libName.} 
</code></pre>
<p><code>magic_file</code> is proc declared in dynlib <code>libmagic.so</code> takes argument p of type <code>MagicPtr</code> and a filepath of type <code>cstring</code> and returns a <code>cstring</code></p>
<p>From manpage:</p>
<blockquote>
<p>The magic_file() function returns a textual description of the contents of the filename argument, or NULL if an error occurred.  If the filename is NULL, then stdin is used.</p>
</blockquote>
<a class="header" href="#step-5-friendly-api" id="step-5-friendly-api"><h3>Step 5: Friendly API</h3></a>
<p>It'd be annoying for people to write C code and take care of pointers and such in a higher level language like nim</p>
<p>So let's expose a proc <code>guessFile</code> takes a filepath and flags and internally use the functions we exposed through the FFI in the previous step.</p>
<pre><code class="language-Nimrod">proc guessFile*(filepath: string, flags: cint = MAGIC_NONE): string =
    var mt : MagicPtr
    mt = magic_open(flags)
    discard magic_load(mt, nil)

    if fileExists(expandFilename(filepath)):
        result = $magic_file(mt, cstring(filepath))
    magic_close(mt)
</code></pre>
<p>Only one note here to convert from <code>cstring</code> to <code>string</code> we use the <code>toString</code> operator <code>$</code></p>
<pre><code>        result = $magic_file(mt, cstring(filepath))
</code></pre>
<a class="header" href="#day-4-linkschecker" id="day-4-linkschecker"><h1>Day 4: LinksChecker</h1></a>
<a class="header" href="#what-to-expect--1" id="what-to-expect--1"><h2>What to expect ?</h2></a>
<p>We will be writing a simple linkschecker in both <code>sequential</code> and <code>asynchronous</code> style in nim</p>
<a class="header" href="#implementation-3" id="implementation-3"><h2>Implementation</h2></a>
<a class="header" href="#step-0-imports" id="step-0-imports"><h3>Step 0: Imports</h3></a>
<pre><code class="language-Nimrod">import  os, httpclient
import strutils
import times
import asyncdispatch
</code></pre>
<a class="header" href="#step-1-data-types" id="step-1-data-types"><h3>Step 1: Data types</h3></a>
<pre><code class="language-Nimrod">type
    LinkCheckResult = ref object 
        link: string
        state: bool
</code></pre>
<p>LinkCheckResult is a simple representation for a link and its state</p>
<a class="header" href="#step-2-go-sequential" id="step-2-go-sequential"><h3>Step 2: GO Sequential!</h3></a>
<pre><code class="language-Nimrod">proc checkLink(link: string) : LinkCheckResult  =
    var client = newHttpClient()
    try:
        return LinkCheckResult(link:link, state:client.get(link).code == Http200)
    except:
        return LinkCheckResult(link:link, state:false)
</code></pre>
<p>Here, we have a proc <code>checkLink</code> takes a link and returns <code>LinkCheckResult</code></p>
<ul>
<li><code>newHttpClient()</code> to create a new client</li>
<li><code>client.get</code> to send a get request to a link and it returns a response</li>
<li><code>response.code</code> gives us the HTTP status code, and we consider a link is valid if its status == 200</li>
<li><code>client.get</code> raises error for invalid structured links that's why we wrapped it a <code>try/except</code> block</li>
</ul>
<pre><code class="language-Nimrod">proc sequentialLinksChecker(links: seq[string]): void = 
    for index, link in links:
        if link.strip() != &quot;&quot;:
            let result = checkLink(link)
            echo result.link, &quot; is &quot;, result.state
</code></pre>
<p>Here, <code>sequentialLinksChecker</code> proc takes sequence of <code>links</code> and executes <code>checkLink</code> on them <code>sequentially</code></p>
<pre><code>LINKS: @[&quot;https://www.google.com.eg&quot;, &quot;https://yahoo.com&quot;, &quot;https://reddit.com&quot;, &quot;https://none.nonadasdet&quot;, &quot;https://github.com&quot;, &quot;&quot;]
SEQUENTIAL::
https://www.google.com.eg is true
https://yahoo.com is true
https://reddit.com is true
https://none.nonadasdet is false
https://github.com is true
7.716497898101807
</code></pre>
<p>On my lousy internet it took 7.7 seconds to finish :(</p>
<a class="header" href="#step-3-go-async" id="step-3-go-async"><h3>Step 3: GO ASYNC!</h3></a>
<p>We can do better than waiting on IO requests to finish</p>
<pre><code class="language-Nimrod">proc checkLinkAsync(link: string): Future[LinkCheckResult] {.async.} =
    var client = newAsyncHttpClient()

    let future = client.get(link)
    yield future
    if future.failed:
        return LinkCheckResult(link:link, state:false)
    else:
        let resp = future.read()
        return LinkCheckResult(link:link, state: resp.code == Http200) 
</code></pre>
<p>Here, we define a <code>checkLinkAsync</code> proc</p>
<ul>
<li>to declare a proc as async we use <code>async</code> pragma</li>
<li>notice the client is of type <code>newAsyncHttpClient</code> that doesn't block on <code>.get</code> calls</li>
<li><code>client.get</code> returns immediately a future that can either fail, and we can infer know that from <code>future.failed</code> or succeed</li>
<li><code>yield future</code> means okay i'm done for now dear <code>event loop</code> you can schedule other tasks and continue my execution when you have more update on my fancy <code>future</code>
when the eventloop comes back because the future now has some updates</li>
<li>clearly, if the <code>future</code> failed we return the link with a <code>false</code> state</li>
<li>otherwise, we get the <code>response</code> object that's enclosed in the future by calling <code>read</code></li>
</ul>
<pre><code class="language-Nimrod">
proc asyncLinksChecker(links: seq[string]) {.async.} = 
    # client.maxRedirects = 0
    var futures = newSeq[Future[LinkCheckResult]]()
    for index, link in links:
        if link.strip() != &quot;&quot;:
            futures.add(checkLinkAsync(link))
    
    # waitFor -&gt; call async proc from sync proc, await -&gt; call async proc from async proc
    let done = await all(futures)
    for x in done:
        echo x.link, &quot; is &quot;, x.state
</code></pre>
<p>Here, we have another async procedure <code>asyncLinksChecker</code> that will take a sequence of <code>links</code> and create futures for all of them and wait when they finish and give us some results</p>
<ul>
<li><code>futures</code> is a sequence for the future results of all the <code>LinkCheckResults</code> for all the links passed to <code>asyncLinksChecker</code> proc</li>
<li>we loop on the links and get <code>future</code> for the  execution of <code>checkLinkAsync</code> and add it to the <code>futures</code> sequence.</li>
<li>we now ask to force to block until we get all of the results out of the futures into <code>done</code> variable</li>
<li>then we print all the results</li>
<li>Please notice <code>await</code> is used only to call <code>async</code> proc from another <code>async</code> proc, and <code>waitFor</code> is used to call <code>async</code> proc from <code>sync</code> proc</li>
</ul>
<pre><code>ASYNC::
https://www.google.com.eg is true
https://yahoo.com is true
https://reddit.com is true
https://none.nonadasdet is false
https://github.com is true
 is false
3.601503849029541
</code></pre>
<a class="header" href="#step-4-simple-cli" id="step-4-simple-cli"><h3>Step 4 simple cli</h3></a>
<pre><code class="language-Nimrod">proc main()=
    echo &quot;Param count: &quot;, paramCount()
    if paramCount() == 1:
        let linksfile = paramStr(1)
        var f = open(linksfile, fmRead)
        let links = readAll(f).splitLines()
        echo &quot;LINKS: &quot; &amp; $links
        echo &quot;SEQUENTIAL:: &quot;
        var t = epochTime()
        sequentialLinksChecker(links)
        echo epochTime()-t
        echo &quot;ASYNC:: &quot;
        t = epochTime()
        waitFor asyncLinksChecker(links)
        echo epochTime()-t

    else:
        echo &quot;Please provide linksfile&quot;
main()
</code></pre>
<p>the only interesting part is <code>waitFor asyncLinksChecker(links)</code> as we said to call <code>async</code> proc from <code>sync</code> proc like this main proc you will need to use <code>waitFor</code></p>
<a class="header" href="#extra-threading" id="extra-threading"><h3>Extra, threading</h3></a>
<pre><code class="language-Nimrod">import threadpool
proc checkLinkParallel(link: string) : LinkCheckResult {.thread.} =
    var client = newHttpClient()
    try:
        return LinkCheckResult(link:link, state:client.get(link).code == Http200)
    except:
        return LinkCheckResult(link:link, state:false)
</code></pre>
<p>Same as before, only <code>thread</code> pragma i used to note that proc will be executed within a thread</p>
<pre><code class="language-Nimrod">proc threadsLinksChecker(links: seq[string]): void = 
    var LinkCheckResults = newSeq[FlowVar[LinkCheckResult]]()
    for index, link in links:
        LinkCheckResults.add(spawn checkLinkParallel(link))  
    
    for x in LinkCheckResults:
        let res = ^x
        echo res.link, &quot; is &quot;, res.state
</code></pre>
<ul>
<li>spawned <code>tasks</code> or <code>threads</code> returns a value of type <code>FlowVar[T]</code>, where <code>T</code> is the return value of the spawned <code>proc</code></li>
<li>To get the value of a <code>FlowVar</code> we use <code>^</code> operator.</li>
</ul>
<blockquote>
<p>Note: you should use <code>nim.cfg</code> with flags <code>-d:ssl</code> to allow working with https</p>
</blockquote>
<a class="header" href="#day-5-creating-ini-parser" id="day-5-creating-ini-parser"><h1>Day 5: Creating INI Parser</h1></a>
<p>this is a pure <a href="https://en.wikipedia.org/wiki/Ini_file">Ini</a> parser for nim</p>
<blockquote>
<p>Nim has advanced <a href="https://nim-lang.org/docs/parsecfg.html">parsecfg</a></p>
</blockquote>
<a class="header" href="#what-to-expect--2" id="what-to-expect--2"><h2>What to expect ?</h2></a>
<pre><code class="language-Nimrod">let sample1 = &quot;&quot;&quot;

[general]
appname = configparser
version = 0.1

[author]
name = xmonader
email = notxmonader@gmail.com


&quot;&quot;&quot;

var d = parseIni(sample1)

# doAssert(d.sectionsCount() == 2)
doAssert(d.getProperty(&quot;general&quot;, &quot;appname&quot;) == &quot;configparser&quot;)
doAssert(d.getProperty(&quot;general&quot;,&quot;version&quot;) == &quot;0.1&quot;)
doAssert(d.getProperty(&quot;author&quot;,&quot;name&quot;) == &quot;xmonader&quot;)
doAssert(d.getProperty(&quot;author&quot;,&quot;email&quot;) == &quot;notxmonader@gmail.com&quot;)

d.setProperty(&quot;author&quot;, &quot;email&quot;, &quot;alsonotxmonader@gmail.com&quot;)
doAssert(d.getProperty(&quot;author&quot;,&quot;email&quot;) == &quot;alsonotxmonader@gmail.com&quot;)
doAssert(d.hasSection(&quot;general&quot;) == true)
doAssert(d.hasSection(&quot;author&quot;) == true)
doAssert(d.hasProperty(&quot;author&quot;, &quot;name&quot;) == true)
d.deleteProperty(&quot;author&quot;, &quot;name&quot;)
doAssert(d.hasProperty(&quot;author&quot;, &quot;name&quot;) == false)

echo d.toIniString()
let s = d.getSection(&quot;author&quot;)
echo $s
</code></pre>
<a class="header" href="#implementation-4" id="implementation-4"><h2>Implementation</h2></a>
<p>You can certainly use regular expressions, like pythons configparser, but we will go for a simpler approach here, also we want to keep it pure so we don't depend on <code>pcre</code></p>
<a class="header" href="#ini-sample" id="ini-sample"><h3>Ini sample</h3></a>
<pre><code class="language-ini">
[general]
appname = configparser
version = 0.1

[author]
name = xmonader
email = notxmonader@gmail.com
</code></pre>
<p>Ini file consists of one or more sections and each section consists of one or more key value pairs separated by <code>=</code></p>
<a class="header" href="#define-your-data-types" id="define-your-data-types"><h3>Define your data types</h3></a>
<pre><code class="language-Nimrod">import tables, strutils

</code></pre>
<p>We will use tables extensively</p>
<pre><code class="language-Nimrod">type Section = ref object
    properties: Table[string, string]
</code></pre>
<p><code>Section</code> type contains <code>properties</code> table represents key value pairs</p>
<pre><code class="language-Nimrod">proc setProperty*(this: Section, name: string, value: string) =
    this.properties[name] = value
</code></pre>
<p>To set property in the underlying <code>properties</code> table</p>
<pre><code class="language-Nimrod">proc newSection*() : Section =
    var s = Section()
    s.properties = initTable[string, string]()
    return s
</code></pre>
<p>To create new Section object</p>
<pre><code class="language-Nimrod">proc `$`*(this: Section) : string =
    return &quot;&lt;Section&quot; &amp; $this.properties &amp; &quot; &gt;&quot;
</code></pre>
<p>Simple <code>toString</code> proc using <code>$</code> operator</p>
<pre><code class="language-Nimrod">type Ini = ref object
    sections: Table[string, Section]
</code></pre>
<p><code>Ini</code> type represents the whole document and contains a table <code>section</code> from <code>sectionName</code> to <code>Section</code> object.</p>
<pre><code>proc newIni*() : Ini = 
    var ini = Ini()
    ini.sections = initTable[string, Section]()
    return ini
</code></pre>
<p>To create new Ini object</p>
<pre><code class="language-Nimrod">proc `$`*(this: Ini) : string = 
    return &quot;&lt;Ini &quot; &amp; $this.sections &amp; &quot; &gt;&quot;
</code></pre>
<p>define friendly <code>toString</code> proc using <code>$</code> operator</p>
<a class="header" href="#define-api" id="define-api"><h3>Define API</h3></a>
<pre><code>proc setSection*(this: Ini, name: string, section: Section) =
    this.sections[name] = section

proc getSection*(this: Ini, name: string): Section =
    return this.sections.getOrDefault(name)

proc hasSection*(this: Ini, name: string): bool =
    return this.sections.contains(name)

proc deleteSection*(this: Ini, name:string) =
    this.sections.del(name)

proc sectionsCount*(this: Ini) : int = 
    echo $this.sections
    return len(this.sections)
</code></pre>
<p>Some helper procs around Ini objects for manipulating sections.</p>
<pre><code class="language-Nimrod">
proc hasProperty*(this: Ini, sectionName: string, key: string): bool=
    return this.sections.contains(sectionName) and this.sections[sectionName].properties.contains(key)

proc setProperty*(this: Ini, sectionName: string, key: string, value:string) =
    echo $this.sections
    if this.sections.contains(sectionName):
        this.sections[sectionName].setProperty(key, value)
    else:
        raise newException(ValueError, &quot;Ini doesn't have section &quot; &amp; sectionName)

proc getProperty*(this: Ini, sectionName: string, key: string) : string =
    if this.sections.contains(sectionName):
        return this.sections[sectionName].properties.getOrDefault(key)
    else:
        raise newException(ValueError, &quot;Ini doesn't have section &quot; &amp; sectionName)


proc deleteProperty*(this: Ini, sectionName: string, key: string) =
    if this.sections.contains(sectionName) and this.sections[sectionName].properties.contains(key):
        this.sections[sectionName].properties.del(key)
    else:
        raise newException(ValueError, &quot;Ini doesn't have section &quot; &amp; sectionName)
</code></pre>
<p>More helpers around properties in the section objects managed by <code>Ini</code> object</p>
<pre><code class="language-Nimrod">proc toIniString*(this: Ini, sep:char='=') : string =
    var output = &quot;&quot;
    for sectName, section in this.sections:
        output &amp;= &quot;[&quot; &amp; sectName &amp; &quot;]&quot; &amp; &quot;\n&quot;
        for k, v in section.properties:
            output &amp;= k &amp; sep &amp; v &amp; &quot;\n&quot; 
        output &amp;= &quot;\n&quot;
    return output
</code></pre>
<p>Simple proc <code>toIniString</code> to convert the nim structures into Ini text string</p>
<a class="header" href="#parse" id="parse"><h3>Parse!</h3></a>
<p>OK, here comes the cool part</p>
<a class="header" href="#parser-states" id="parser-states"><h4>Parser states</h4></a>
<pre><code class="language-Nimrod">type ParserState = enum
    readSection, readKV
</code></pre>
<p>Here we have two states</p>
<ul>
<li>readSection: when we are supposed to extract section name from the current line</li>
<li>readKV: when we are supposed to read the line in key value pair mode</li>
</ul>
<a class="header" href="#parseini-proc" id="parseini-proc"><h4>ParseIni proc</h4></a>
<pre><code class="language-Nimrod">proc parseIni*(s: string) : Ini = 
</code></pre>
<p>Here we define a proc <code>parseIni</code> that takes a string <code>s</code> and creates an <code>Ini</code> object</p>
<pre><code class="language-Nimrod">    var ini = newIni()
    var state: ParserState = readSection
    let lines = s.splitLines
    
    var currentSectionName: string = &quot;&quot;
    var currentSection = newSection()
</code></pre>
<ul>
<li><code>ini</code> is the object to be returned after parsing</li>
<li><code>state</code> the current parser state (weather it's <code>readSection</code> or <code>readKV</code>)</li>
<li><code>lines</code> input string splitted into lines <code>as we are a lines based parser</code></li>
<li><code>currentSectionName</code> to keep track of what section we are currently in</li>
<li><code>currentSection</code> to populate <code>ini.sections</code> with <code>Section</code> object using <code>setSection</code> proc</li>
</ul>
<pre><code class="language-Nimrod">   for line in lines:
</code></pre>
<p>for each line</p>
<pre><code class="language-Nimrod">         if line.strip() == &quot;&quot; or line.startsWith(&quot;;&quot;) or line.startsWith(&quot;#&quot;):
            continue
</code></pre>
<p>We continue if line is safe to igore <code>empty line</code> or starts with <code>;</code> or <code>#</code></p>
<pre><code class="language-Nimrod">        if line.startsWith(&quot;[&quot;) and line.endsWith(&quot;]&quot;):
            state = readSection
</code></pre>
<p>if line startswith <code>[</code> and ends with <code>]</code> then we set parser state to <code>readSection</code></p>
<pre><code class="language-Nimrod">        if state == readSection:
            currentSectionName = line[1..&lt;line.len-1]
            ini.setSection(currentSectionName, currentSection)
            state = readKV
            continue
</code></pre>
<p>if parser <code>state</code> is <code>readSection</code></p>
<ul>
<li>extract section name <code>between [ and ]</code></li>
<li>add section object to the ini under the current section name</li>
<li>change <code>state</code> to <code>readKV</code> to read key value pairs</li>
<li>continue the loop on the nextline as we're done processing the section name.</li>
</ul>
<pre><code class="language-Nimrod">        if state == readKV:
            let parts = line.split({'='})
            if len(parts) == 2:
                let key = parts[0].strip()
                let val = parts[1].strip()
                ini.setProperty(currentSectionName, key, val)
</code></pre>
<p>if <code>state</code> is <code>readKV</code></p>
<ul>
<li>extract <code>key</code> and <code>val</code> by splitting the line on <code>=</code></li>
<li><code>setProperty</code> under the <code>currentSectionName</code> using <code>key</code> and <code>val</code></li>
</ul>
<pre><code class="language-Nimrod">    return ini
</code></pre>
<p>Here we return the populated <code>ini</code> object.</p>
<a class="header" href="#day-6-manage-your-dotfiles-easily-with-nistow" id="day-6-manage-your-dotfiles-easily-with-nistow"><h1>Day 6: Manage your dotfiles easily with nistow</h1></a>
<p>Today we will create a tool to manage our dotfiles easily.</p>
<a class="header" href="#dotfiles-layout" id="dotfiles-layout"><h2>Dotfiles layout</h2></a>
<pre><code>        i3
        `-- .config
            `-- i3
                `-- config
</code></pre>
<p>So we have here a directory named i3 in the very top <code>indicates APP_NAME</code> and under it a tree of config paths. Here it means <code>config</code> file is supposed to be linked under <code>.config/i3/config</code> relative to <code>destination directory</code></p>
<blockquote>
<p>Home directory is the default destination.</p>
</blockquote>
<a class="header" href="#what-do-we-expect" id="what-do-we-expect"><h2>What do we expect?</h2></a>
<pre><code>➜  ~ nistow --help
    Stow 0.1.0
        -h | --help     : show help
        -v | --version  : show version
        --verbose       : verbose messages
        -s | --simulate : simulate stow operation
        -f | --force    : override old links
        -a | --app      : application path to stow
        -d | --dest     : destination to stow to
</code></pre>
<ul>
<li><code>--simulate</code> flag used to simulate on the filesystem without actual linking</li>
<li><code>--app</code> application directory that's compatible with the dotfiles layoud described above.</li>
<li><code>--dest</code> destination to symlink files under, defaults to home dir.</li>
</ul>
<pre><code>nistow --app=/home/striky/wspace/dotfiles/localdir --dest=/tmp/tmpconf --verbose
</code></pre>
<a class="header" href="#implementation-5" id="implementation-5"><h2>Implementation</h2></a>
<pre><code class="language-Nimrod">proc writeHelp() = 
    echo &quot;&quot;&quot;
Stow 0.1.0 (Manage your dotfiles easily)

Allowed arguments:
    -h | --help     : show help
    -v | --version  : show version
    --verbose       : verbose messages
    -s | --simulate : simulate stow operation
    -f | --force    : override old links
    -a | --app      : application path to stow
    -d | --dest     : destination to stow to

    &quot;&quot;&quot;
</code></pre>
<p><code>writeHelp</code> is a simple proc to write help string to the stdout</p>
<pre><code class="language-Nimrod">proc writeVersion() =
    echo &quot;Stow version 0.1.0&quot;
</code></pre>
<p>To write version</p>
<pre><code class="language-Nimrod">proc cli*() =
</code></pre>
<p>Entry point for out commandline application</p>
<pre><code class="language-Nimrod">  var 
    simulate, verbose, force: bool = false
    app, dest: string = &quot;&quot;
</code></pre>
<p>Variables represents various options we allow in the application.</p>
<pre><code class="language-Nimrod">  if paramCount() == 0:
    writeHelp()
    quit(0)
</code></pre>
<p>If no arguments passed we will write the help string and <code>exit</code> or <code>quit</code> according to nim with <code>exit status</code> 0</p>
<pre><code class="language-Nimrod">  for kind, key, val in getopt():
    case kind
    of cmdLongOption, cmdShortOption:
        case key
        of &quot;help&quot;, &quot;h&quot;: 
            writeHelp()
            quit()
        of &quot;version&quot;, &quot;v&quot;:
            writeVersion()
            quit()
        of &quot;simulate&quot;, &quot;s&quot;: simulate = true
        of &quot;verbose&quot;: verbose = true
        of &quot;force&quot;, &quot;f&quot;: force = true
        of &quot;app&quot;, &quot;a&quot;: app = val
        of &quot;dest&quot;, &quot;d&quot;: dest = val 
        else:
          discard
    else:
      discard 
</code></pre>
<p>Here we parse the commandline string using <code>getopt</code>.</p>
<pre><code class="language-Nimrod">  for kind, key, val in getopt():
    case kind
    of cmdLongOption, cmdShortOption:
</code></pre>
<p>So for <code>--app=/home/striky/dotfiles/i3 -f</code>
kind for <code>--app</code> is <code>cmdLongOption</code> and for <code>-f</code> is <code>cmdShortOption</code>
key for <code>--app</code> is <code>app</code> and for <code>-f</code> is <code>f</code>
val for <code>--app</code> is <code>/home/striky/dotfiles/i3</code>
val for <code>-f</code> we set to <code>true</code> in our parsing, because it's mainly like a switch <code>boolean</code> if it exists it means we want it set to true.</p>
<pre><code class="language-Nimrod">  if dest.isNilOrEmpty():
    dest = getHomeDir()
</code></pre>
<p>Here we set default <code>dest</code> to homeDir</p>
<pre><code class="language-Nimrod">  if app.isNilOrEmpty():
    echo &quot;Make sure to provide --app flags&quot;
    quit(1)
</code></pre>
<p>Here we exit with error <code>exit status</code> 1 if app isn't set.</p>
<pre><code class="language-Nimrod">  try:
    stow(getLinkableFiles(appPath=app, dest=dest), simulate=simulate, verbose=verbose, force=force)
  except ValueError:
    echo &quot;Error happened: &quot; &amp; getCurrentExceptionMsg()
</code></pre>
<p>Here we try to stow all the linkable files in <code>app</code> dir to <code>dest</code> dir and pass all the options we collected from the command line arguments <code>simulate</code>, <code>verbose</code>, <code>force</code>, and wrapped around <code>try/except</code> to show error to the user</p>
<pre><code class="language-Nimrod">when isMainModule:
  cli()
</code></pre>
<p>invoke our entry point <code>cli</code> if this module is the main module.</p>
<p>OK! back to stow and getLinkableFiles</p>
<p>We start with <code>getLinkableFiles</code>. Remember the dotfiles hierarchy?</p>
<pre><code>    # appPath: application's dotfiles directory
    #     we expect dir to have the hierarchy.
    #     i3
    #     `-- .config
    #         `-- i3
    #         `-- config
</code></pre>
<p>We want to get all the files in there with full path and the link file to each one will be exactly the same except for the <code>appPath</code> name will be changed to <code>dest</code> path</p>
<pre><code>[/home/striky/wspace/dotfiles/i3]/.config/i3/config -&gt; [/home/striky]/.config/i3/config
__________________appPath________                      _____dest____
</code></pre>
<pre><code class="language-Nimrod">type
  LinkInfo = tuple[original:string, dest:string] 
</code></pre>
<p>Simple type to represent the original path and where to symlink to</p>
<pre><code class="language-Nimrod">proc getLinkableFiles*(appPath: string, dest: string=expandTilde(&quot;~&quot;)): seq[LinkInfo] =

    # collects the linkable files in a certain app.

    # appPath: application's dotfiles directory
    #     we expect dir to have the hierarchy.
    #     i3
    #     `-- .config
    #         `-- i3
    #         `-- config

    # dest: destination of the link files : default is the home of user.
</code></pre>
<p><code>getLinkableFiles</code> is a proc takes <code>appPath</code> and <code>dest</code> and returns a <code>seq</code> of LinkInfo contains this transformation for each file.</p>
<pre><code>[/home/striky/wspace/dotfiles/i3]/A_FILE_PATH -&gt; [/home/striky]A_FILE_PATH
__________________apppath________                _____dest____
</code></pre>
<pre><code class="language-Nimrod">  var appPath = expandTilde(appPath)
  if not dirExists(appPath):
    raise newException(ValueError, fmt(&quot;App path {appPath} doesn't exist.&quot;))
  var linkables = newSeq[LinkInfo]()
  for filepath in walkDirRec(appPath, yieldFilter={pcFile}):
    let linkpath = filepath.replace(appPath, dest)
    var linkInfo : LinkInfo = (original:filepath, dest:linkpath)
    linkables.add(linkInfo)
  return linkables
</code></pre>
<p>Here, we walk over the <code>appPath</code> dir using <code>walkDirRec</code> and specify in <code>yieldFilter</code> argument that we're interested in <code>pcFile</code> &quot;file path component&quot;, just call it entries of type regular file.</p>
<pre><code class="language-Nimrod">proc stow(linkables: seq[LinkInfo], simulate: bool=true, verbose: bool=true, force: bool=false) = 
    # Creates symoblic links and related directories

    # linkables is a list of tuples (filepath, linkpath) : List[Tuple[file_path, link_path]]
    # simulate does simulation with no effect on the filesystem: bool
    # verbose shows log messages: bool

  for linkinfo in linkables:
    let (filepath, linkpath) = linkinfo
    if verbose:
      echo(fmt(&quot;Will link {filepath} -&gt; {linkpath}&quot;))

    if not simulate:
      createDir(parentDir(linkpath))
      if not fileExists(linkpath):
        createSymlink(filepath, linkpath)
      else:
        if force:
          removeFile(linkpath)
          createSymlink(filepath, linkpath)
        else:
          if verbose:
            echo(fmt(&quot;Skipping linking {filepath} -&gt; {linkpath}&quot;))
</code></pre>
<p>stow is pretty easy procedure, it takes in a list of <code>LinksInfo</code> that has all the information (original filename and destination symlink) and does the symlinking based on if it's not a simulation and prints the messages if verbose is set to true</p>
<p>Feel free to send improvements to this tutorial or nistow :)</p>
<p><a href="https://github.com/xmonader/nistow">Complete source code</a> available here https://github.com/xmonader/nistow</p>
<a class="header" href="#day-7-shorturl-service" id="day-7-shorturl-service"><h1>Day 7: Shorturl service</h1></a>
<p>Today, we will develop a url shortening service like <code>bit.ly</code> or something</p>
<a class="header" href="#imports-1" id="imports-1"><h2>imports</h2></a>
<pre><code class="language-Nimrod">import jester, asyncdispatch, htmlgen, json, os, strutils, strformat, db_sqlite
</code></pre>
<ul>
<li>
<p>jester: is sinatra like framework</p>
</li>
<li>
<p>asyncdispatch: for async/await instructions</p>
</li>
<li>
<p>htmlgen: to generate html pages</p>
</li>
<li>
<p>json: to parse json string into nim structures and dump json structures to strings</p>
</li>
<li>
<p>db_sqlite: to work on sqlite databse behind our application</p>
</li>
</ul>
<a class="header" href="#database-connection" id="database-connection"><h2>Database connection</h2></a>
<pre><code class="language-Nimrod"># hostname can be something configurable &quot;http://ni.m:5000&quot;
let hostname = &quot;localhost:5000&quot;
var theDb : DbConn
</code></pre>
<ul>
<li>
<p><code>hostname</code> is the basepath for our site to access it, and can be configurable using <code>/etc/hosts</code> file or using even <code>reverse proxy</code> like <code>caddy</code>, or in real world case you will have a dns record for your site.</p>
</li>
<li>
<p><code>theDb</code> is the connection object to work with <code>sqlite</code> database.</p>
</li>
</ul>
<pre><code class="language-Nimrod">if not fileExists(&quot;/tmp/mytest.db&quot;):
  theDb = open(&quot;/tmp/mytest.db&quot;, nil, nil, nil)
  theDb.exec(sql(&quot;&quot;&quot;create table urls (
      id   INTEGER PRIMARY KEY,
      url  VARCHAR(255) NOT NULL
     )&quot;&quot;&quot;
  ))
else:
  theDb = open(&quot;/tmp/mytest.db&quot;, nil, nil, nil)
</code></pre>
<ul>
<li>We check if the database file doesn't exist <code>/tmp/mytest.db</code> we create a <code>urls</code> table  otherwise we just get the connection and do nothing</li>
</ul>
<a class="header" href="#jester-and-http-endpoints" id="jester-and-http-endpoints"><h2>Jester and http endpoints</h2></a>
<pre><code class="language-Nimrod">routes:
</code></pre>
<ul>
<li>jester defines a DSL to work on routes</li>
</ul>
<pre><code class="language-Nimrod">METHOD ROUTE_PATH:
    ##codeblock
</code></pre>
<ul>
<li>
<p>METHOD can be <code>get</code> <code>post</code> or any <code>http</code> verb</p>
</li>
<li>
<p>ROUTE_PATH is the path accessed on the server for instance <code>/users</code>, <code>/user/52</code>, here <code>52</code> is a query parameter when route is defined  like this<code>/user/@id</code></p>
</li>
</ul>
<a class="header" href="#home-page" id="home-page"><h3>HOME page</h3></a>
<p>Here we handle <code>GET</code> requests on <code>/home</code> path on our server:</p>
<pre><code class="language-Nimrod"> get &quot;/home&quot;:
  var htmlout = &quot;&quot;&quot;
    &lt;html&gt;
      &lt;title&gt;NIM SHORT&lt;/title&gt;
      &lt;head&gt;
        &lt;script
      src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot;
      integrity=&quot;sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=&quot;
      crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;

      &lt;script&gt;
        function postData(url, data) {
          // Default options are marked with *
          return fetch(url, {
            body: JSON.stringify(data), // must match 'Content-Type' header
            cache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached
            credentials: 'same-origin', // include, same-origin, *omit
            headers: {
              'user-agent': 'Mozilla/4.0 MDN Example',
              'content-type': 'application/json'
            },
            method: 'POST', // *GET, POST, PUT, DELETE, etc.
            mode: 'cors', // no-cors, cors, *same-origin
            redirect: 'follow', // manual, *follow, error
            referrer: 'no-referrer', // *client, no-referrer
          })
          .then(resp =&gt; resp.json())
      }

      $(document).ready(function() {
        $('#btnsubmit').on('click', function(e){
          e.preventDefault();
          postData('/shorten', {url: $(&quot;#url&quot;).val()})
          .then( data =&gt; {
            let id = data[&quot;id&quot;]
            $(&quot;#output&quot;).html(`&lt;a href=&quot;%%hostname/${id}&quot;&gt;Shortlink: ${id}&lt;/a&gt;`);
           });
      });
    });
      &lt;/script&gt;
      &lt;/head&gt;
      &lt;body&gt;
          &lt;div&gt;
            &lt;form&gt;
              &lt;label&gt;URL&lt;/label&gt;
              &lt;input type=&quot;url&quot; name=&quot;url&quot; id=&quot;url&quot; /&gt;
              &lt;button id=&quot;btnsubmit&quot; type=&quot;button&quot;&gt;SHORT!&lt;/button
            &lt;/form&gt;
          &lt;/div&gt;

          &lt;div id=&quot;output&quot;&gt;

          &lt;/div&gt;
      &lt;/body&gt;
    &lt;/html&gt;
    &quot;&quot;&quot;
    htmlout = htmlout.replace(&quot;%%hostname&quot;, hostname)
    resp  htmlout
</code></pre>
<ul>
<li>
<p>Include jquery framework</p>
</li>
<li>
<p>Create a form with in <code>div tag with 1 textinput to allow user to enter a url</code></p>
</li>
<li>
<p>override form submission to do an ajax request</p>
</li>
<li>
<p>on the button shorturl click event we send a post request to <code>/shorten</code> endpoint in the background using <code>fetch</code> api and whenever we get a result we parse the json data and extract the <code>id</code> from it and put the new url in the <code>output</code> div</p>
</li>
<li>
<p><code>resp</code> to return a response to the user and it can return a <code>http status</code> too</p>
</li>
</ul>
<a class="header" href="#shorten-endpoint" id="shorten-endpoint"><h3>Shorten endpoint</h3></a>
<pre><code class="language-Nimrod">  post &quot;/shorten&quot;:
    let url = parseJson(request.body).getOrDefault(&quot;url&quot;).getStr()
    if not url.isNilOrEmpty():
      var id = theDb.getValue(sql&quot;SELECT id FROM urls WHERE url=?&quot;, url)
      if id.isNilOrEmpty():
        id = $theDb.tryInsertId(sql&quot;INSERT INTO urls (url) VALUES (?)&quot;, url)
      var jsonResp = $(%*{&quot;id&quot;: id})
      resp Http200, jsonResp
    else:
      resp Http400, &quot;please specify url in the posted data.&quot;
</code></pre>
<p>Here we handle <code>POST</code> requests on <code>/shorten</code> endpoint</p>
<ul>
<li>
<p>get the url from parsed json post data. please note that POST data is <code>available under request.body</code> <code>explained in the previous section</code></p>
</li>
<li>
<p>if url is passed we try to check if it's there in our <code>urls</code> table, if it's there we return it, otherwise we insert it in the table.</p>
</li>
<li>
<p>if the url isn't passed we return a badrequest <code>400</code> status code.</p>
</li>
<li>
<p><code>parseJson</code>: loads json from a string and you can get value using <code>getOrDefault</code> and <code>getStr</code> to get string value, there's getBool, and so on.</p>
</li>
<li>
<p><code>getValue</code> to get the id from the result of the select statement <code>returns the first column from the first row in the result set</code></p>
</li>
<li>
<p><code>tryInsertId</code> executes insert statement and returns the id of the new row</p>
</li>
<li>
<p>after successfull insertion we would like to return <code>json</code> serialized string to the user <code>$(%*{&quot;id&quot;: id})</code></p>
</li>
<li>
<p><code>%*</code> is a macro to convert nim struct into json node and to convert it to string we wrap <code>$</code> around it</p>
</li>
</ul>
<a class="header" href="#shorturls-redirect" id="shorturls-redirect"><h3>Shorturls redirect</h3></a>
<pre><code class="language-Nimrod">  get &quot;/@Id&quot;:
    let url = theDb.getValue(sql&quot;SELECT url FROM urls WHERE id=?&quot;, @&quot;Id&quot;)
    if url.isNilOrEmpty():
      resp Http404, &quot;Don't know that url&quot;
    else:
      redirect url
</code></pre>
<ul>
<li>
<p>Here we fetch whatever path <code>@Id</code> the user trying to access <code>except for /home and /shorten</code> and we try to get the long url for that path</p>
</li>
<li>
<p>If the path is resolved to a url we <code>redirect</code> the user to to or we show an error message</p>
</li>
<li>
<p><code>@&quot;Id&quot;</code> gets the value of <code>@Id</code> query parameter : notice the <code>@</code> position in both situation</p>
</li>
</ul>
<a class="header" href="#run" id="run"><h2>RUN</h2></a>
<pre><code class="language-Nimrod">runForever()
</code></pre>
<p>start jester webserver</p>
<p>Code is available here <a href="https://gist.github.com/xmonader/d41a5c9f917eadb90d3025e7b7e748dd">https://gist.github.com/xmonader/d41a5c9f917eadb90d3025e7b7e748dd</a></p>
<a class="header" href="#day-8-minitest" id="day-8-minitest"><h1>Day 8: minitest</h1></a>
<p>I'm a big fan of <a href="http://www.gigamonkeys.com/book/">Practical Common Lisp</a> and It has a chapter on <a href="http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html">building a unittest framework using macros</a> and I didn't get the chance to tinker with nim macros just yet, So today we will be building almost the same thing in nim.</p>
<a class="header" href="#so-whats-up" id="so-whats-up"><h2>So what's up?</h2></a>
<p>Imagine you want to check for some expression and print a specific message donating the expression</p>
<pre><code class="language-Nimrod">  doAssert(1==2, &quot;1 == 2 failed&quot;)
</code></pre>
<p>Here we want to assure that 1==2 or show a message with <code>1==2 failed</code> and it goes on for whatever we want to check for</p>
<pre><code class="language-Nimrod">  doAssert(1+2==3, &quot;1+2 == 3 failed&quot;)
  doAssert(5*2==10, &quot;5*2 == 10 failed&quot;)

</code></pre>
<p>We can already see the boilerplate here, repeating the expression twice one for the check and one for the message itself.</p>
<a class="header" href="#what-to-expect-2" id="what-to-expect-2"><h2>What to expect?</h2></a>
<p>We expect having a DSL to remove the boilerplate we're suffering from in the prev. section.</p>
<pre><code class="language-Nimrod">  check(3==1+2)
  check(6+5*2 == 16)
</code></pre>
<p>And this will print</p>
<pre><code>3 == 1 + 2 .. passed
6 + 5 * 2 == 16 .. passed
</code></pre>
<p>And it should evolve to allow grouping of test checks</p>
<pre><code class="language-Nimrod">  check(3==1+2)
  check(6+5*2 == 16)
  
  suite &quot;Arith&quot;:
    check(1+2==3)
    check(3+2==5)

  suite &quot;Strs&quot;:
    check(&quot;HELLO&quot;.toLowerAscii() == &quot;hello&quot;)
    check(&quot;&quot;.isNilOrEmpty() == true)

</code></pre>
<p>Resulting something like this</p>
<pre><code>3 == 1 + 2 .. passed
6 + 5 * 2 == 16 .. passed
==================================================
Arith
==================================================
 1 + 2 == 3 .. passed
 3 + 2 == 5 .. passed
==================================================
Strs
==================================================
 &quot;HELLO&quot;.toLowerAscii() == &quot;hello&quot; .. passed
 &quot;&quot;.isNilOrEmpty() == true .. passed

</code></pre>
<a class="header" href="#implementation-6" id="implementation-6"><h2>Implementation</h2></a>
<p>So nim has two way to do macros</p>
<a class="header" href="#templates" id="templates"><h3>templates</h3></a>
<p>Which are like functions that called in compilation time like <code>preprocessor</code></p>
<p>From the nim manual</p>
<pre><code class="language-Nimrod">template `!=` (a, b: untyped): untyped =
  # this definition exists in the System module
  not (a == b)

assert(5 != 6) # the compiler rewrites that to: assert(not (5 == 6))
</code></pre>
<p>so in compile time <code>5 != 6</code> will be converted into <code>not ( 5 == 6)</code> and the whole expression will be <code>assert(not ( 5== 6))</code></p>
<p>So what're we gonna do is check for the passed expression to convert it to a string to be printed in the terminal output and if the expression fails we append <code>failed</code> message or any other custom failure message</p>
<pre><code class="language-Nimrod">template check*(exp:untyped, failureMsg:string=&quot;failed&quot;, indent:uint=0): void =
  let indentationStr = repeat(' ', indent) 
  let expStr: string = astToStr(exp)
  var msg: string
  if not exp:
    if msg.isNilOrEmpty():
      msg = indentationStr &amp; expStr &amp; &quot; .. &quot; &amp; failureMsg
  else:
    msg = indentationStr &amp; expStr &amp; &quot; .. passed&quot;
      
  echo(msg)
</code></pre>
<ul>
<li>
<p><code>untyped</code> means the expression doesn't have to have a type yet, imagine passing variable name that doesn't exist yet <code>defineVar(myVar, 5)</code> so here <code>myVar</code> needs to be untyped or the compiler will complain. check the manual for more info https://nim-lang.org/docs/manual.html#templates</p>
</li>
<li>
<p><code>astToStr</code> converts the AST <code>exp</code> to a string</p>
</li>
<li>
<p><code>indent</code> amount of spaces prefixing the message.</p>
</li>
</ul>
<a class="header" href="#macros" id="macros"><h3>Macros</h3></a>
<p>Nim provides us with a way to access the AST in a very low level when we templates don't cut it.</p>
<p>What we expected is having a <code>suite</code> macro</p>
<pre><code>  suite &quot;Strs&quot;:
    check(&quot;HELLO&quot;.toLowerAscii() == &quot;hello&quot;)
    check(&quot;&quot;.isNilOrEmpty() == true)
</code></pre>
<p>that takes a <code>name</code> for the suite and bunch of <code>statements</code></p>
<ul>
<li>Please note there're two kind of macros and we're interested in the <code>statements macro</code> here</li>
<li>Statments macro is a macro that has <code>colon</code> <code>:</code> operator followed by bunch of statements</li>
</ul>
<a class="header" href="#dumptree" id="dumptree"><h4>dumpTree</h4></a>
<p>dumpTree is amazing to debug the ast and print them in a good visual way</p>
<pre><code class="language-Nimrod">
  dumpTree:
    suite &quot;Strs&quot;:
      check(&quot;HELLO&quot;.toLowerAscii() == &quot;hello&quot;)

</code></pre>
<pre><code>Ident ident&quot;suite&quot;
    StrLit Strs
    StmtList
      Call
        Ident ident&quot;check&quot;
        Infix
          Ident ident&quot;==&quot;
          Call
            DotExpr
              StrLit HELLO
              Ident ident&quot;toLowerAscii&quot;
          StrLit hello

</code></pre>
<ul>
<li><code>dumpTree</code> says it got <code>Identifier Ident</code> named <code>suite</code></li>
<li><code>suite</code> contains <code>StringLiteral</code> node with value <code>Strs</code></li>
<li><code>suite</code> contains <code>StmtList</code> node</li>
<li>first statement in <code>StmtList</code> is a <code>call</code> statement</li>
<li><code>call</code> statement consist of <code>procedure</code> name <code>check</code> in this case and args list and so on..</li>
</ul>
<pre><code class="language-Nimrod">macro suite*(name:string, exprs: untyped) : typed = 
</code></pre>
<p>Here, we define a macro <code>suite</code> takes <code>name</code> and bunch of statements <code>exprs</code></p>
<ul>
<li>Macro must return an AST in our case will be list of statements of <code>check</code> call statemenets</li>
<li>Need the messages to be indented</li>
</ul>
<p>To achieve the indentation we can either print tab before calling <code>check</code> or overwrite check to pass <code>indent</code> option, we will go with overwrite the <code>check</code> call ASTs</p>
<pre><code class="language-Nimrod">  var result = newStmtList()
</code></pre>
<p>We will be returning a list of statments right?</p>
<pre><code>  let equline = newCall(&quot;repeat&quot;, newStrLitNode(&quot;=&quot;), newIntLitNode(50))
</code></pre>
<p>statement node that equals <code>repeat(&quot;=&quot;, 50)</code></p>
<pre><code class="language-Nimrod">  let writeEquline = newCall(&quot;echo&quot;, equline)
</code></pre>
<p>statement node the equals <code>echo repeat(&quot;=&quot;, 50)</code></p>
<pre><code class="language-Nimrod">  add(result, writeEquline, newCall(&quot;echo&quot;, name))
  add(result, writeEquline)
</code></pre>
<p>this will generate</p>
<pre><code>================
$name
================
</code></pre>
<p>Now we iterate over the passed statements to <code>suite</code> macro and check for its kind</p>
<pre><code class="language-Nimrod">  for i in 0..&lt;exprs.len:
    var exp = exprs[i]
    let expKind = exp.kind
    case expKind
    of nnkCall:
      case exp[0].kind
      of nnkIdent:
        let identName = $exp[0].ident
        if identName == &quot;check&quot;:
</code></pre>
<ul>
<li>If we're in a <code>check</code> call we will convert it from <code>check(expr)</code> =&gt; <code>check(expr, &quot;&quot;, 1)</code></li>
</ul>
<pre><code class="language-Nimrod">          var checkWithIndent = exp
          checkWithIndent.add(newStrLitNode(&quot;&quot;))
          checkWithIndent.add(newIntLitNode(1))
          add(result, checkWithIndent)
</code></pre>
<p>otherwise we add any other statement as is unprocessesed.</p>
<pre><code class="language-Nimrod">      else:
        add(result, exp) 
    else:
      discard
        
  return result
</code></pre>
<p>Code is available on https://github.com/xmonader/nim-minitest</p>
<a class="header" href="#day-9-tic-tac-toe" id="day-9-tic-tac-toe"><h1>Day 9: Tic tac toe</h1></a>
<p>Who didn't play <a href="https://en.wikipedia.org/wiki/Tic-tac-toe">Tic tac toe</a> with his friends? :)</p>
<a class="header" href="#what-to-expect-3" id="what-to-expect-3"><h2>What to expect</h2></a>
<p>Today we will implement tic tac toe game in Nim, with 2 modes</p>
<ul>
<li>Human vs Human</li>
<li>Human vs AI</li>
</ul>
<a class="header" href="#implementation-7" id="implementation-7"><h2>Implementation</h2></a>
<p>So, let's get it. The winner in the game is the first one who manages to get 3 cells on the board to be the same in the same column or row or diagonally first.</p>
<a class="header" href="#imports-2" id="imports-2"><h3>imports</h3></a>
<pre><code class="language-Nimrod">import sequtils, tables, strutils, strformat, random, os, parseopt2

randomize()
</code></pre>
<a class="header" href="#constraints-and-objects" id="constraints-and-objects"><h3>Constraints and objects</h3></a>
<p>As the game allow turns we should have a way to keep track of the next player</p>
<pre><code>let NEXT_PLAYER = {&quot;X&quot;:&quot;O&quot;, &quot;O&quot;:&quot;X&quot;}.toTable
</code></pre>
<p>Here we use a table to tell us the next player</p>
<a class="header" href="#board" id="board"><h4>Board</h4></a>
<pre><code class="language-Nimrod">type 
  Board = ref object of RootObj
    list: seq[string]
</code></pre>
<p>Here we define a simple class representing the board</p>
<ul>
<li>list is a sequence representing the cells <code>maybe cells is a better name</code></li>
<li>please note list is just a sequenece of elements <code>0 1 2 3 4 5 6 7 8</code> but we visualize it as</li>
</ul>
<pre><code>0 1 2
3 4 5
6 7 9
</code></pre>
<p>instead of using a 2d array for the sake of simplicity</p>
<pre><code class="language-Nimrod">let WINS = @[ @[0,1,2], @[3,4,5], @[6,7,8], @[0, 3, 6], @[1,4,7], @[2,5,8], @[0,4,8], @[2,4,6] ]
</code></pre>
<p>We talked <code>WIN</code> patterns cells in the same row or the same column or in same diagonal</p>
<pre><code class="language-Nimrod">proc newBoard(): Board =
  var b = Board()
  b.list = @[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;]
  return b
</code></pre>
<p>this is the initializer of the board and sets the cell value to the string represention  of its index</p>
<a class="header" href="#winning" id="winning"><h5>Winning</h5></a>
<pre><code class="language-Nimrod">proc done(this: Board): (bool, string) =
    for w in WINS:
        if this.list[w[0]] == this.list[w[1]] and this.list[w[1]]  == this.list[w[2]]:
          if this.list[w[0]] == &quot;X&quot;:
            return (true, &quot;X&quot;)
          elif this.list[w[0]] == &quot;O&quot;:
            return (true, &quot;O&quot;)
    if all(this.list, proc(x:string):bool = x in @[&quot;O&quot;, &quot;X&quot;]) == true:
        return (true, &quot;tie&quot;)
    else:
        return (false, &quot;going&quot;)
</code></pre>
<p>Here we check for the state of the game and the winner if all of the item in <code>WIN</code> patterns are the same</p>
<pre><code class="language-Nimrod">proc `$`(this:Board): string =
  let rows: seq[seq[string]] = @[this.list[0..2], this.list[3..5], this.list[6..8]]
  for row  in rows:
    for cell in row:
      stdout.write(cell &amp; &quot; | &quot;)
    echo(&quot;\n--------------&quot;)
</code></pre>
<p>Here we have the string representation of the board so we can show it as 3x3 grid in a lovely way</p>
<pre><code class="language-Nimrod">proc emptySpots(this:Board):seq[int] =
    var emptyindices = newSeq[int]()
    for i in this.list:
      if i.isDigit():
        emptyindices.add(parseInt(i))
    return emptyindices
</code></pre>
<p>Here we have a simple helper function that returns the empty spots indices <code>the spots that doesn't have X or O in it</code>, remember all the cells are initialized to the string representation of their indices.</p>
<a class="header" href="#game" id="game"><h4>Game</h4></a>
<pre><code class="language-Nimrod">type
  Game = ref object of RootObj
    currentPlayer*: string
    board*: Board
    aiPlayer*: string
    difficulty*: int


proc newGame(aiPlayer:string=&quot;&quot;, difficulty:int=9): Game =
  var
    game = new Game

  game.board = newBoard()
  game.currentPlayer = &quot;X&quot;
  game.aiPlayer = aiPlayer
  game.difficulty = difficulty
  
  return game
        # 0 1 2
        # 3 4 5
        # 6 7 8 
</code></pre>
<p>Here we have another object representing the game and the players and the difficulty and wether it has an AI player or not and who is the current player</p>
<ul>
<li>difficulty is only logical in case of AI, it means when does the AI start calculating moves and considering scenarios, 9 is the hardest, 0 is the easiest.</li>
</ul>
<pre><code class="language-Nimrod">proc changePlayer(this:Game) : void =
  this.currentPlayer = NEXT_PLAYER[this.currentPlayer]   
</code></pre>
<p>Simple procedure to switch turns between players</p>
<a class="header" href="#start-the-game" id="start-the-game"><h4>Start the game</h4></a>
<pre><code class="language-Nimrod">
proc startGame*(this:Game): void=
    while true:
        echo this.board
        if this.aiPlayer != this.currentPlayer:
          stdout.write(&quot;Enter move: &quot;)
          let move = stdin.readLine()
          this.board.list[parseInt($move)] = this.currentPlayer
        this.change_player()
        let (done, winner) = this.board.done()

        if done == true:
          echo this.board
          if winner == &quot;tie&quot;:
              echo(&quot;TIE&quot;)
          else:
              echo(&quot;WINNER IS :&quot;, winner )
          break           

</code></pre>
<p>Here if we don't have <code>aiPlayer</code> if not set it's just a game with 2 humans switching turns and checking for the winner after each move</p>
<a class="header" href="#minmax-and-ai-support" id="minmax-and-ai-support"><h3>Minmax and AI support</h3></a>
<p><a href="https://en.wikipedia.org/wiki/Minimax">Minmax</a> is an algorithm mainly used to predict the possible moves in the future and how to minimize the losses and maximize the chances of winning</p>
<ul>
<li>https://www.youtube.com/watch?v=6ELUvkSkCts</li>
<li>https://www.youtube.com/watch?v=CwziaVrM_vc&amp;t=1199s</li>
</ul>
<pre><code class="language-Nimrod">
type 
  Move = tuple[score:int, idx:int]
</code></pre>
<p>We need a type Move on a certain idx to represent if it's a good/bad move <code>depending on the score</code></p>
<ul>
<li>good means minimizing chances of the human to win or making AI win =&gt; high score +10</li>
<li>bad  means maximizing chances of the human to win or making AI lose =&gt; low score -10</li>
</ul>
<p>So let's say we are in this situation</p>
<pre><code>O X X
X 4 5 
X O O
</code></pre>
<p>And it's <code>AI turn</code> we have two possible moves (4 or 5)</p>
<pre><code>O X X
X 4 O 
X O O
</code></pre>
<p>this move (to 5) is clearly wrong because the next move to human will allow him to complete the diagonal (2, 4, 6) So this is a bad move we give it score -10
or</p>
<pre><code>O X X
X O 5 
X O O
</code></pre>
<p>this move (to 4) minimizes the losses (leads to a TIE instead of making human wins) so we give it a higher score</p>
<pre><code class="language-Nimrod">proc getBestMove(this: Game, board: Board, player:string): Move =
        let (done, winner) = board.done()
        # determine the score of the move by checking where does it lead to a win or loss.
        if done == true:
            if winner ==  this.aiPlayer:
                return (score:10, idx:0)
            elif winner != &quot;tie&quot;: #human
                return (score:(-10), idx:0)
            else:
                return (score:0, idx:0)
            
        let empty_spots = board.empty_spots()
        var moves = newSeq[Move]() 
        for idx in empty_spots:
            # we calculate more new trees depending on the current situation and see where the upcoming moves lead
            var newboard = newBoard()

            newboard.list = map(board.list, proc(x:string):string=x)
            newboard.list[idx] = player
            let score = this.getBestMove(newboard, NEXT_PLAYER[player]).score
            let idx = idx
            let move = (score:score, idx:idx)
            moves.add(move)
        
        if player == this.aiPlayer:
          return max(moves)          
          # var bestScore = -1000
          # var bestMove: Move 
          # for m in moves:
          #   if m.score &gt; bestScore:
          #     bestMove = m
          #     bestScore = m.score
          # return bestMove
        else:
          return min(moves)          
          # var bestScore = 1000
          # var bestMove: Move 
          # for m in moves:
          #   if m.score &lt; bestScore:
          #     bestMove = m
          #     bestScore = m.score
          # return bestMove

</code></pre>
<p>Here we have a highly annotated <code>getBestMove</code> procedure to calculate recursively the best move for us</p>
<p>Now our startGame should look like this</p>
<pre><code class="language-Nimrod">proc startGame*(this:Game): void=
    while true:
        ##old code

        ## AI check
        else:
            if this.currentPlayer == this.aiPlayer:
              let emptyspots = this.board.emptySpots()
              if len(emptyspots) &lt;= this.difficulty:
                  echo(&quot;AI MOVE..&quot;)
                  let move = this.getbestmove(this.board, this.aiPlayer)
                  this.board.list[move.idx] = this.aiPlayer
              else:
                  echo(&quot;RANDOM GUESS&quot;)
                  this.board.list[emptyspots.rand()] = this.aiPlayer
  
        ## oldcode    

</code></pre>
<p>Here we allow the game to use difficulty which means when does the AI starts calculating the moves and making the tree? from the beginning 9 cells left or when there're 4 cells left? you can set it the way you want it, and until u reach the starting difficulty situation AI will use random guesses (from the available <code>emptyspots</code>) instead of calculating</p>
<a class="header" href="#cli-entry" id="cli-entry"><h3>CLI entry</h3></a>
<pre><code class="language-Nimrod">proc writeHelp() = 
  echo &quot;&quot;&quot;
TicTacToe 0.1.0 (MinMax version)
Allowed arguments:
  -h | --help         : show help
  -a | --ai           : AI player [X or O]
  -l | --difficulty   : destination to stow to
  &quot;&quot;&quot;

proc cli*() =
  var 
    aiplayer = &quot;&quot;
    difficulty = 9

  for kind, key, val in getopt():
    case kind
    of cmdLongOption, cmdShortOption:
        case key
        of &quot;help&quot;, &quot;h&quot;: 
            writeHelp()
            # quit()
        of &quot;aiplayer&quot;, &quot;a&quot;:
          echo &quot;AIPLAYER: &quot; &amp; val
          aiplayer = val
        of &quot;level&quot;, &quot;l&quot;: difficulty = parseInt(val)
        else:
          discard
    else:
      discard 

  let g = newGame(aiPlayer=aiplayer, difficulty=difficulty)
  g.startGame()


when isMainModule:
  cli()

</code></pre>
<p>Code is available on <a href="https://github.com/xmonader/nim-tictactoe/blob/master/src/nim_tictactoe_cli.nim">https://github.com/xmonader/nim-tictactoe/blob/master/src/nim_tictactoe_cli.nim</a></p>
<a class="header" href="#day-10-tic-tac-toe-with-gui" id="day-10-tic-tac-toe-with-gui"><h1>Day 10: Tic tac toe with GUI!!</h1></a>
<p>Hopefully, you're done with day 9 and enjoyed playing tic tac toe.</p>
<a class="header" href="#expectation" id="expectation"><h2>Expectation</h2></a>
<p>It's fun to play on the command line, but it'd be very cool to have some GUI with some buttons using <a href="https://github.com/nim-lang/ui">libui</a> bindings in Nim</p>
<ul>
<li>make sure to install it using <code>nimble install ui</code></li>
</ul>
<a class="header" href="#implementation-8" id="implementation-8"><h2>Implementation</h2></a>
<p>In the previous day we reached some good abstraction separating the logic for the command line gui and the minmax algorithm and it's not tightly coupled</p>
<a class="header" href="#minimal-ui-application" id="minimal-ui-application"><h3>minimal ui application</h3></a>
<pre><code class="language-Nimrod">proc gui*() = 
  var mainwin = newWindow(&quot;tictactoe&quot;, 400, 500, true)
  show(mainwin)
  mainLoop()

when isMainModule:
  # cli()
  init()
  gui()
</code></pre>
<p>Here we create a window 400x500 with a title <code>tictactoe</code> and we show it and start its mainLoop <code>getting ready to receive and dispatch events</code></p>
<a class="header" href="#tictactoe-gui" id="tictactoe-gui"><h3>TicTacToe GUI</h3></a>
<p>We can imagine the gui to be something like that</p>
<pre><code>---------------------------------------------
|  ---------------------------------------  |
+  | INFO LABEL | button to restart       | +
|  ---------------------------------------| |
+  |--------------------------------------| +
|  |  btn     |    btn  |   btn           | |
+  |--------------------------------------| +
|  |  btn     |    btn  |   btn           | |
+  |--------------------------------------| +
|  |  btn     |    btn  |   btn           | |
+  |--------------------------------------| +
---------------------------------------------
</code></pre>
<ul>
<li>a window that contains  a vertical box</li>
<li>the vertical box contains 4 rows</li>
<li>first row to show information about the current game and a button to reset the game</li>
<li>and the other rows represent the 3x3 tictactoe grid that will reflect <code>game.list</code> :)</li>
<li>and 9 buttons to be pressed to set X or O</li>
<li>we will support human vs AI so when human presses a button it gets disabled and the AI presses the button that minimizes its loss and that button gets disabled too.</li>
</ul>
<pre><code class="language-Nimrod">proc gui*() = 
  var mainwin = newWindow(&quot;tictactoe&quot;, 400, 500, true)

  # game object to contain the state, the players, the difficulty,...
  var g = newGame(aiPlayer=&quot;O&quot;, difficulty=9)

  var currentMove = -1
  mainwin.margined = true
  mainwin.onClosing = (proc (): bool = return true)


  # set up the boxes 
  let box = newVerticalBox(true)
  let hbox0 = newHorizontalBox(true)
  let hbox1 = newHorizontalBox(true)
  let hbox2 = newHorizontalBox(true)
  let hbox3 = newHorizontalBox(true)
  # list of buttons 
  var buttons = newSeq[Button]()

  # information label
  var labelInfo = newLabel(&quot;Info: Player X turn&quot;)
  hbox0.add(labelInfo)

  # restart button
  hbox0.add(newButton(&quot;Restart&quot;, proc() = 
                            g =newGame(aiPlayer=&quot;O&quot;, difficulty=9)
                            for i, b in buttons.pairs:
                              b.text = $i
                              b.enable()))
</code></pre>
<p>Here we setup the layout we just described and create a button Restart that resets the game again and restore the buttons text and enables them all</p>
<pre><code class="language-Nimrod">  # create the buttons
  for i in countup(0, 8):
    var handler : proc() 
    closureScope:
      let senderId = i
      handler = proc() =
        currentMove = senderId
        g.board.list[senderId] = g.currentPlayer
        g.change_player()
        labelInfo.text = &quot;Current player: &quot; &amp; g.currentPlayer
        for i, v in g.board.list.pairs:
          buttons[i].text = v
        let (done, winner) = g.board.done()
        if done == true:
          echo g.board
          if winner == &quot;tie&quot;:
              labelInfo.text = &quot;Tie..&quot;
          else:
            labelInfo.text = winner &amp; &quot; won.&quot;
        else:
          aiPlay()
        buttons[senderId].disable()

    buttons.add(newButton($i, handler))
</code></pre>
<ul>
<li>Here we create the buttons please notice we are using <code>closureScope</code> feature to capture the button id to keep track of which button is clicked</li>
<li>after pressing set set the text of the button to <code>X</code></li>
<li>we disable the button so we don't receive anymore events.</li>
<li>switch turns</li>
<li>update the information label whether about the next player or the game state</li>
<li>if the game is still going we ask the AI for a move</li>
</ul>
<pre><code class="language-Nimrod">
  # code to run when the game asks the ai to play (after each move from the human..)
  proc aiPlay() = 
    if g.currentPlayer == g.aiPlayer:
      let emptySpots = g.board.emptySpots()
      if len(emptySpots) &lt;= g.difficulty:
        let move = g.getBestMove(g.board, g.aiPlayer)
        g.board.list[move.idx] = g.aiPlayer
        buttons[move.idx].disable()
      else:
        let rndmove = emptyspots.rand()
        g.board.list[rndmove] = g.aiPlayer
    g.change_player()
    labelInfo.text = &quot;Current player: &quot; &amp; g.currentPlayer

    for i, v in g.board.list.pairs:
      buttons[i].text = v
      
    let (done, winner) = g.board.done()

    if done == true:
      echo g.board
      if winner == &quot;tie&quot;:
          labelInfo.text = &quot;Tie..&quot;
      else:
        labelInfo.text = winner &amp; &quot; won.&quot;

</code></pre>
<ul>
<li>using minmax algorithm from the previous day we calculate the best move</li>
<li>change the button text to <code>O</code></li>
<li>disable the button</li>
<li>update the information label</li>
</ul>
<pre><code class="language-Nimrod">
 hbox1.add(buttons[0])
 hbox1.add(buttons[1])
 hbox1.add(buttons[2])

 hbox2.add(buttons[3])
 hbox2.add(buttons[4])
 hbox2.add(buttons[5])

 hbox3.add(buttons[6])
 hbox3.add(buttons[7])
 hbox3.add(buttons[8])
 
 box.add(hbox0, true)
 box.add(hbox1, true)
 box.add(hbox2, true)
 box.add(hbox3, true)
 mainwin.setChild(box)

</code></pre>
<ul>
<li>Here we add the buttons to their correct rows in the correct columns and set the main widget</li>
</ul>
<pre><code class="language-Nimrod">  show(mainwin)
  mainLoop()

when isMainModule:
  init()
  gui()
</code></pre>
<p>Code is available on <a href="https://github.com/xmonader/nim-tictactoe/blob/master/src/nim_tictactoe_gui.nim">https://github.com/xmonader/nim-tictactoe/blob/master/src/nim_tictactoe_gui.nim</a></p>
<a class="header" href="#day-11--bake-applications" id="day-11--bake-applications"><h1>Day 11 ( Bake applications)</h1></a>
<p>I used to work on application 2 years ago, and It was a bit like ansible defining recipes to create applications and managing their dependencies.</p>
<a class="header" href="#what-to-expect-4" id="what-to-expect-4"><h2>What to expect</h2></a>
<p>Today we will be doing something very simple to track our dependencies and print the bash commands for each task like Makefile.</p>
<pre><code class="language-makefile">HEADERS = program.h headers.h

default: program

program.o: program.c $(HEADERS)
    gcc -c program.c -o program.o

program: program.o
    gcc program.o -o program

clean:
    -rm -f program.o
    -rm -f program
</code></pre>
<p>Basically, makefile consists of</p>
<ul>
<li>Variables</li>
<li>Targets</li>
<li>Dependencies</li>
</ul>
<p><code>variables</code> like <code>HEADERS=...</code>, <code>targets</code> whatever precedes the <code>:</code> like <code>clean</code>, <code>program</code>, <code>program.o</code>, <code>dependencies</code> are what a target depends on, so for instance <code>program</code> target that generates the executable requires <code>program.o</code> dependency to be executed first.</p>
<a class="header" href="#example-api-usage" id="example-api-usage"><h2>Example API usage</h2></a>
<a class="header" href="#normal-usage" id="normal-usage"><h3>Normal usage</h3></a>
<pre><code class="language-Nimrod">  var b = initBake()
  b.add_task(&quot;publish&quot;, @[&quot;build-release&quot;], &quot;print publish&quot;)
  b.add_task(&quot;build-release&quot;, @[&quot;nim-installed&quot;], &quot;print exec command to build release mode&quot;)
  b.add_task(&quot;nim-installed&quot;, @[&quot;curl-installed&quot;], &quot;print curl LINK | bash&quot;)
  b.add_task(&quot;curl-installed&quot;, @[&quot;apt-installed&quot;], &quot;apt-get install curl&quot;)
  b.add_task(&quot;apt-installed&quot;, @[], &quot;code to install apt...&quot;)
  b.run_task(&quot;publish&quot;)
</code></pre>
<p>OUTPUT:</p>
<pre><code>code to install apt...
apt-get install curl
print curl LINK | bash
print exec command to build release mode
print publish
</code></pre>
<a class="header" href="#circular-dependencies" id="circular-dependencies"><h3>Circular dependencies</h3></a>
<pre><code class="language-Nimrod">  var b = initBake()
  b.add_task(&quot;publish&quot;, @[&quot;build-release&quot;], &quot;print publish&quot;)
  b.add_task(&quot;build-release&quot;, @[&quot;nim-installed&quot;], &quot;print exec command to build release mode&quot;)
  b.add_task(&quot;nim-installed&quot;, @[&quot;curl-installed&quot;], &quot;print curl LINK | bash&quot;)
  b.add_task(&quot;curl-installed&quot;, @[&quot;publish&quot;, &quot;apt-installed&quot;], &quot;apt-get install curl&quot;)
  b.add_task(&quot;apt-installed&quot;, @[], &quot;code to install apt...&quot;)
  b.run_task(&quot;publish&quot;)

</code></pre>
<p>Output:</p>
<pre><code>Found cycle please fix:@[&quot;build-release&quot;, &quot;nim-installed&quot;, &quot;curl-installed&quot;, &quot;publish&quot;, &quot;build-release&quot;]
</code></pre>
<a class="header" href="#implementation-9" id="implementation-9"><h3>Implementation</h3></a>
<a class="header" href="#imports-3" id="imports-3"><h4>Imports</h4></a>
<pre><code class="language-Nimrod">import strformat, strutils, tables, sequtils, algorithm
</code></pre>
<a class="header" href="#graphs" id="graphs"><h4>Graphs</h4></a>
<p>Graphs are very powerful data structure and used to solve lots of problems, like getting the shortest route and detecting circular dependencies in our code today :)</p>
<p>So How to represent graph?
Well, we will use <a href="https://en.wikipedia.org/wiki/Adjacency_list">Adjaceny list</a></p>
<a class="header" href="#objects" id="objects"><h4>Objects</h4></a>
<pre><code class="language-Nimrod">
type Task = object
  requires*: seq[string]
  actions*: string
  name*: string

proc `$`(this: Task): string = 
  return fmt(&quot;Task {this.name} Requirements: {this.requires} , actions {this.actions}&quot;)

</code></pre>
<p>Task object represnts a <code>target</code> in makefile language, and it has a name, actions code and list of dependencies</p>
<pre><code class="language-Nimrod">type Bake = ref object
  tasksgraph* : Table[string, seq[string]]
  tasks*      : Table[string, Task]
</code></pre>
<p>Bake object has <code>tasksgraph</code> adjaceny list representing the tasks and their dependencies and tasks table that maps taskname to task object</p>
<a class="header" href="#adding-a-task" id="adding-a-task"><h4>Adding a task</h4></a>
<pre><code class="language-Nimrod">
proc addTask*(this: Bake, taskname: string, deps: seq[string], actions:string) : void = 
  var t =  Task(name:taskname, requires:deps, actions:actions)
  this.tasksgraph[taskname] = deps
  this.tasks[taskname] = t
</code></pre>
<ul>
<li>We update the adjacency list with (taskname and its dependencies)</li>
<li>Add task object to tasks Table with key task name</li>
</ul>
<a class="header" href="#running-tasks" id="running-tasks"><h4>Running tasks</h4></a>
<pre><code class="language-Nimrod">
proc runTask*(this: Bake, taskname: string): void =
  # CODE OMITTED FOR FINIDNG CYCLES..

  var deps = newSeq[string]()
  var seen = newSeq[string]()

  this.runTaskHelper(taskname, deps, seen)      

  for tsk in deps:
      let t = this.tasks.getOrDefault(tsk)
      echo(t.actions)

</code></pre>
<ul>
<li>Before running a task we should check if it has a cycle first.</li>
<li>Keep track of dependencies and the seen tasks so far so we don't <code>run seen tasks</code> again. (for instance if we have target install-wget and target install-curl and both require target <code>apt-get update</code>, so we want to run <code>apt-get update</code> only once )</li>
</ul>
<p>for example</p>
<pre><code>code to install apt...
apt-get install curl
print curl LINK | bash
print exec command to build release mode
print publish
</code></pre>
<ul>
<li>Call <code>runTaskHelper</code> procedure to walk through all the <code>tasks</code> and their <code>dependencies</code> and get us a list of deps <code>each will update deps variable as we will be sending it by reference</code></li>
<li>After getting correct dependencies tasks sorted we execute <code>in our case we will just echo actions property</code></li>
</ul>
<p>and now to <code>runTaskHelper</code> that basically updates our dependencies list and put the task execution in order</p>
<pre><code class="language-Nimrod">
proc runTaskHelper(this: Bake, taskname: string, deps: var seq[string], seen: var seq[string]) : void = 
  if taskname in seen:
    echo &quot;[+] Solved {taskname} before no need to repeat action&quot;
  var tsk = this.tasks.getOrDefault(taskname)

  seen.add(taskname)
  if len(tsk.requires) &gt; 0:
    for c in this.tasksgraph[tsk.name]:
      this.runTaskHelper(c, deps, seen)
  deps.add(taskname)
</code></pre>
<a class="header" href="#detecting-cycles" id="detecting-cycles"><h4>Detecting cycles</h4></a>
<p>To detect a cycle we use <code>DFS</code> depth first search algorithm basically going from one node as deep as we can go for each of its neigbours and <code>Graph coloring</code>. <a href="https://www.youtube.com/watch?v=rKQaZuoUR4M">Youtube Lecture</a></p>
<p>Explanation from geeksforgeeks</p>
<pre><code>    WHITE : Vertex is not processed yet.  Initially
            all vertices are WHITE.

    GRAY : Vertex is being processed (DFS for this 
        vertex has started, but not finished which means
        that all descendants (ind DFS tree) of this vertex
        are not processed yet (or this vertex is in function
        call stack)

    BLACK : Vertex and all its descendants are 
            processed.

    While doing DFS, if we encounter an edge from current 
    vertex to a GRAY vertex, then this edge is back edge 
    and hence there is a cycle.
</code></pre>
<p>OK, back to nim</p>
<p>1- Defining colors</p>
<pre><code class="language-Nimrod">type NodeColor = enum
  ncWhite, ncGray, ncBlack
</code></pre>
<p>2- Graph has Cycle</p>
<pre><code class="language-Nimrod">proc graphHasCycle(graph: Table[string, seq[string]]): (bool, Table[string, string]) =
  var colors = initTable[string, NodeColor]()
  for node, deps in graph:
    colors[node] = ncWhite
  
  var parentMap = initTable[string, string]()
  var hasCycle = false 
  for node, deps in graph:
    parentMap[node] = &quot;null&quot;
    if colors[node] == ncWhite:
      hasCycleDFS(graph, node, colors, hasCycle, parentMap)
    if hasCycle:
      return (true, parentMap)
  return (false, parentMap)
</code></pre>
<p>3- Depth First Function</p>
<pre><code class="language-Nimrod">proc hasCycleDFS(graph:Table[string, seq[string]] , node: string, colors: var Table[string, NodeColor], has_cycle: var bool, parentMap: var Table[string, string]) =
  if hasCycle:
      return
  colors[node] = ncGray 

  for dep in graph[node]:
    parentMap[dep] = node
    if colors[dep] == ncGray:
      hasCycle = true   
      parentMap[&quot;__CYCLESTART__&quot;] = dep
      return
    if colors[dep] == ncWhite:  
      hasCycleDFS(graph, dep, colors, hasCycle, parentMap)
  colors[node] = ncBlack  

</code></pre>
<a class="header" href="#whats-next" id="whats-next"><h3>What's next?</h3></a>
<ul>
<li>support for variables</li>
<li>recipes maybe using yaml file</li>
<li>modules like ansible?</li>
</ul>
<a class="header" href="#day-12-implementing-redis-protocol" id="day-12-implementing-redis-protocol"><h1>Day 12: Implementing Redis Protocol</h1></a>
<p>Today we will implement RESP (REdis Serialization Protocol) in Nim. Hopefully you read Day 2 on bencode data format (encoding/parsing) because we will be using the same techniques.</p>
<a class="header" href="#resp" id="resp"><h2>RESP</h2></a>
<p>From <a href="https://redis.io/topics/protocol">redis protocol page</a>.</p>
<pre><code>Redis clients communicate with the Redis server using a protocol called RESP (REdis Serialization Protocol). While the protocol was designed specifically for Redis, it can be used for other client-server software projects.

RESP is a compromise between the following things:

Simple to implement.
Fast to parse.
Human readable.
RESP can serialize different data types like integers, strings, arrays. There is also a specific type for errors. Requests are sent from the client to the Redis server as arrays of strings representing the arguments of the command to execute. Redis replies with a command-specific data type.
</code></pre>
<p>So, basically we have 5 types (ints, strings, bulkstrings, errors, arrays)</p>
<a class="header" href="#what-do-we-expect-1" id="what-do-we-expect-1"><h2>What do we expect?</h2></a>
<ul>
<li>able to decode strings into Reasonable structures in Nim</li>
</ul>
<pre><code class="language-Nimrod">  echo decodeString(&quot;*3\r\n:1\r\n:2\r\n:3\r\n\r\n&quot;)
  # # @[1, 2, 3]
  echo decodeString(&quot;+Hello, World\r\n&quot;)
  # # Hello, World
  echo decodeString(&quot;-Not found\r\n&quot;)
  # # Not found
  echo decodeString(&quot;:1512\r\n&quot;)
  # # 1512
  echo $decodeString(&quot;$32\r\nHello, World THIS IS REALLY NICE\r\n&quot;)
  # Hello, World THIS IS REALLY NICE
  echo decodeString(&quot;*2\r\n+Hello World\r\n:23\r\n&quot;)
  # @[Hello World, 23]
  echo decodeString(&quot;*2\r\n*3\r\n:1\r\n:2\r\n:3\r\n\r\n*5\r\n:5\r\n:7\r\n+Hello Word\r\n-Err\r\n$6\r\nfoobar\r\n&quot;)
  # @[@[1, 2, 3], @[5, 7, Hello Word, Err, foobar]]
  echo $decodeString(&quot;*4\r\n:51231\r\n$3\r\nfoo\r\n$-1\r\n$3\r\nbar\r\n&quot;)
  # @[51231, foo, , bar]
</code></pre>
<ul>
<li>able to encode Nim structures representing Redis values into RESP</li>
</ul>
<pre><code class="language-Nimrod">  echo $encodeValue(RedisValue(kind:vkStr, s:&quot;Hello, World&quot;))
  # # +Hello, World
  echo $encodeValue(RedisValue(kind:vkInt, i:341))
  # # :341
  echo $encodeValue(RedisValue(kind:vkError, err:&quot;Not found&quot;))
  # # -Not found
  echo $encodeValue(RedisValue(kind:vkArray, l: @[RedisValue(kind:vkStr, s:&quot;Hello World&quot;), RedisValue(kind:vkInt, i:23)]  ))
  # #*2
  # #+Hello World
  # #:23

  echo $encodeValue(RedisValue(kind:vkBulkStr, bs:&quot;Hello, World THIS IS REALLY NICE&quot;))
  # #$32
  # # Hello, World THIS IS REALLY NICE  

</code></pre>
<a class="header" href="#implementation-10" id="implementation-10"><h2>Implementation</h2></a>
<a class="header" href="#imports-and-constants" id="imports-and-constants"><h3>Imports and constants</h3></a>
<p>Let's starts with main imports</p>
<pre><code>import strformat, strutils, sequtils,
const CRLF = &quot;\r\n&quot;
const REDISNIL = &quot;\0\0&quot;
</code></pre>
<ul>
<li>CRLF is really important because lots of the protocol depends on that separator <code>\r\n</code></li>
<li>REDISNIL <code>\0\0</code> to represent <code>Nil</code> values</li>
</ul>
<a class="header" href="#data-types" id="data-types"><h3>Data types</h3></a>
<p>Again, as in Bencode chapter we will define a variant <code>RedisValue</code> that represents All redis datatypes <code>strings, errors, bulkstrings, ints, arrays</code></p>
<pre><code class="language-Nimrod">
  ValueKind = enum
    vkStr, vkError, vkInt, vkBulkStr, vkArray

  RedisValue* = ref object
    case kind*: ValueKind
    of vkStr: s*: string
    of vkError : err*: string
    of vkInt: i*: int
    of vkBulkStr: bs*: string
    of vkArray: l*: seq[RedisValue]

</code></pre>
<p>Let's add <code>$</code>, <code>hash</code>, <code>==</code> procedures</p>
<pre><code class="language-Nimrod">
import hashes

proc `$`*(obj: RedisValue): string = 
  result = case obj.kind
  of vkStr : obj.s
  of vkBulkStr: obj.bs
  of vkInt : $obj.i
  of vkArray: $obj.l
  of vkError: obj.err

proc hash*(obj: RedisValue): Hash = 
  result = case obj.kind
  of vkStr : !$(hash(obj.s))
  of vkBulkStr: !$(hash(obj.bs))
  of vkInt : !$(hash(obj.i))
  of vkArray: !$(hash(obj.l))
  of vkError: !$(hash(obj.err))

proc `==`* (a, b: RedisValue): bool =
  ## Check two nodes for equality
  if a.isNil:
      result = b.isNil
  elif b.isNil or a.kind != b.kind:
      result = false
  else:
      case a.kind
      of vkStr:
          result = a.s == b.s
      of vkBulkStr:
          result = a.s == b.s
      of vkInt:
          result = a.i == b.i
      of vkArray:
          result = a.l == b.l
      of vkError:
          result = a.err == b.err

</code></pre>
<a class="header" href="#encoder" id="encoder"><h3>Encoder</h3></a>
<p>Encoding is just converting the variant <code>RedisValue</code> to the correct representation according to RESP</p>
<a class="header" href="#encode-simple-strings" id="encode-simple-strings"><h4>Encode simple strings</h4></a>
<p>To encode simple strings specs says <code>OK</code> should be <code>+OK\r\n</code></p>
<pre><code class="language-Nimrod">
proc encodeStr(v: RedisValue) : string =
  return fmt&quot;+{v.s}{CRLF}&quot;
</code></pre>
<a class="header" href="#encode-errors" id="encode-errors"><h4>Encode Errors</h4></a>
<p>To encode errors we should precede it with <code>-</code> and end it with <code>\r\n</code>. So <code>Notfound</code> should be encoded as <code>-Notfound\r\n</code></p>
<pre><code class="language-Nimrod">proc encodeErr(v: RedisValue) : string =
  return fmt&quot;-{v.err}{CRLF}&quot;
</code></pre>
<a class="header" href="#encode-ints" id="encode-ints"><h4>Encode Ints</h4></a>
<p>Ints are encoded <code>:NUM\r\n</code> so 95 is <code>:95\r\n</code></p>
<pre><code class="language-Nimrod">proc encodeInt(v: RedisValue) : string =
  return fmt&quot;:{v.i}{CRLF}&quot;
</code></pre>
<a class="header" href="#encode-bulkstrings" id="encode-bulkstrings"><h4>Encode Bulkstrings</h4></a>
<p>From RESP page</p>
<pre><code>Bulk Strings are used in order to represent a single binary safe string up to 512 MB in length.

Bulk Strings are encoded in the following way:

A &quot;$&quot; byte followed by the number of bytes composing the string (a prefixed length), terminated by CRLF.
The actual string data.
A final CRLF.
So the string &quot;foobar&quot; is encoded as follows:

&quot;$6\r\nfoobar\r\n&quot;
When an empty string is just:

&quot;$0\r\n\r\n&quot;
RESP Bulk Strings can also be used in order to signal non-existence of a value using a special format that is used to represent a Null value. In this special format the length is -1, and there is no data, so a Null is represented as:

&quot;$-1\r\n&quot;
</code></pre>
<pre><code class="language-Nimrod">proc encodeBulkStr(v: RedisValue) : string =
  return fmt&quot;${v.bs.len}{CRLF}{v.bs}{CRLF}&quot;

</code></pre>
<a class="header" href="#encode-arrays" id="encode-arrays"><h4>Encode Arrays</h4></a>
<p>To encode an array we do <code>*</code> followed by array length then <code>\r\n</code> then encode each element then end the array encoding with <code>\r\n</code></p>
<ul>
<li>As we are calling <code>encode</code> <code>we should forward declared it</code></li>
</ul>
<pre><code class="language-Nimrod">
proc encode*(v: RedisValue) : string 
proc encodeArray(v: RedisValue): string = 
  var res = &quot;*&quot; &amp; $len(v.l) &amp; CRLF
  for el in v.l:
    res &amp;= encode(el)
  res &amp;= CRLF
  return res

</code></pre>
<p>So for instance to encode <code>encodeValue(RedisValue(kind:vkArray, l: @[RedisValue(kind:vkStr, s:&quot;Hello World&quot;), RedisValue(kind:vkInt, i:23)] ))</code>
The result should be</p>
<pre><code>*2\r\n
+Hello World\r\n
:23\r\n
\r\n
</code></pre>
<a class="header" href="#encode-any-data-type" id="encode-any-data-type"><h4>Encode any data type</h4></a>
<p>Here we switch on the passed variant and dispatch the encoding to the reasonable encoder.</p>
<pre><code class="language-Nimrod">proc encode*(v: RedisValue) : string =
  case v.kind 
  of vkStr: return encodeStr(v)
  of vkInt:    return encodeInt(v)
  of vkError:  return encodeErr(v)
  of vkBulkStr: return encodeBulkStr(v)
  of vkArray: return encodeArray(v)

</code></pre>
<a class="header" href="#decoder" id="decoder"><h3>Decoder</h3></a>
<p>Decoding is converting RESP representation into the correct Nim structures <code>RedisValue</code>, Basically the reverse of what we did in the previous chapter</p>
<p>Please note: Basic strategy is Returning the <code>RedisValue</code> and the <code>length of processed characters</code></p>
<a class="header" href="#decode-simple-string" id="decode-simple-string"><h4>Decode simple string</h4></a>
<pre><code class="language-Nimrod">proc decodeStr(s: string): (RedisValue, int) =
  let crlfpos = s.find(CRLF)
  return (RedisValue(kind:vkStr, s:s[1..crlfpos-1]), crlfpos+len(CRLF))
</code></pre>
<p>So, Here we are creating RedisValue of kind <code>vkStr</code> of the string between <code>+</code> and <code>\r\n</code></p>
<a class="header" href="#decode-errors" id="decode-errors"><h4>Decode errors</h4></a>
<pre><code class="language-Nimrod">proc decodeError(s: string): (RedisValue, int) =
  let crlfpos = s.find(CRLF)
  return (RedisValue(kind:vkError, err:s[1..crlfpos-1]), crlfpos+len(CRLF))
</code></pre>
<p>Here we are creating RedisValue of kind <code>vkError</code> of the string between <code>-</code> and <code>\r\n</code></p>
<a class="header" href="#decode-ints" id="decode-ints"><h4>Decode ints</h4></a>
<p>Nums as we said are the values between <code>:</code> and <code>\r\n</code> so we <code>parseInt</code> of the characters between <code>:</code> and <code>\r\n</code> and create RedisValue of kind <code>vkInt</code> with that parsed int.</p>
<pre><code class="language-Nimrod">proc decodeInt(s: string): (RedisValue, int) =
  var i: int
  let crlfpos = s.find(CRLF)
  let sInt = s[1..crlfpos-1]
  if sInt.isDigit():
    i = parseInt(sInt)
  return (RedisValue(kind:vkInt, i:i), crlfpos+len(CRLF))
</code></pre>
<a class="header" href="#decode-bulkstrings" id="decode-bulkstrings"><h4>Decode bulkstrings</h4></a>
<p>Bulkstrings are between <code>$</code> followed by the string length and <code>\r\n</code></p>
<ul>
<li>string length == 0: empty string</li>
<li>string length == -1: nil</li>
<li>string length &gt; 0: string with data</li>
</ul>
<pre><code class="language-Nimrod">
proc decodeBulkStr(s:string): (RedisValue, int) = 
  let crlfpos = s.find(CRLF)
  var bulklen = 0
  let slen = s[1..crlfpos-1]
  bulklen = parseInt(slen)
  var bulk: string
  if bulklen == -1:
      bulk = nil
      return (RedisValue(kind:vkBulkStr, bs:REDISNIL), crlfpos+len(CRLF))
  else:
    let nextcrlf = s.find(CRLF, crlfpos+len(CRLF))
    bulk = s[crlfpos+len(CRLF)..nextcrlf-1] 
    return (RedisValue(kind:vkBulkStr, bs:bulk), nextcrlf+len(CRLF))
</code></pre>
<a class="header" href="#decode-arrays" id="decode-arrays"><h4>Decode arrays</h4></a>
<p>This is the trickiest part is to decode array</p>
<ul>
<li>first we need to get the length between <code>*</code> and <code>\r\n</code></li>
<li>then decode objects <code>array length</code> times, and add them to <code>arr</code></li>
<li>As we are calling <code>decode</code> <code>we should forward declared it</code></li>
</ul>
<pre><code class="language-Nimrod">proc decode(s: string): (RedisValue, int)
proc decodeArray(s: string): (RedisValue, int) =
  var arr = newSeq[RedisValue]()
  var arrlen = 0
  var crlfpos = s.find(CRLF)
  var arrlenStr = s[1..crlfpos-1]
  if arrlenStr.isDigit():
     arrlen = parseInt(arrlenStr)
  
  var nextobjpos = s.find(CRLF)+len(CRLF)
  var i = nextobjpos 
  
  if arrlen == -1:
    
    return (RedisValue(kind:vkArray, l:arr), i)
  
  while i &lt; len(s) and len(arr) &lt; arrlen:
    var pair = decode(s[i..len(s)])
    var obj = pair[0]
    arr.add(obj)
    i += pair[1]
  return (RedisValue(kind:vkArray, l:arr), i+len(CRLF))
</code></pre>
<p>So this RESP</p>
<pre><code>*2\r\n
+Hello World\r\n
:23\r\n
\r\n
</code></pre>
<p>Should be decoded to <code>RedisValue(kind:vkArray, l: @[RedisValue(kind:vkStr, s:&quot;Hello World&quot;), RedisValue(kind:vkInt, i:23)] )</code></p>
<a class="header" href="#decode-any-object" id="decode-any-object"><h4>Decode any object</h4></a>
<p>Based on the first character we dispatch to the correct decoder then we skip <code>the processed count</code> in the string to decode the next object.</p>
<pre><code class="language-Nimrod">proc decode(s: string): (RedisValue, int) =
  var i = 0 
  while i &lt; len(s):
    var curchar = $s[i]
    if curchar == &quot;+&quot;:
      var pair = decodeStr(s[i..s.find(CRLF, i)+len(CRLF)])
      var obj =  pair[0]
      var count =  pair[1]
      i += count
      return (obj, i)
    elif curchar == &quot;-&quot;:
      var pair = decodeError(s[i..s.find(CRLF, i)+len(CRLF)])
      var obj =  pair[0]
      var count =  pair[1]
      i += count
      return (obj, i)
    elif curchar == &quot;$&quot;:
      var pair = decodeBulkStr(s[i..len(s)])
      var obj =  pair[0]
      var count =  pair[1]
      i += count
      return (obj, i)
    elif curchar == &quot;:&quot;:
      var pair = decodeInt(s[i..s.find(CRLF, i)+len(CRLF)])
      var obj =  pair[0]
      var count =  pair[1]
      i += count
      return (obj, i)
    elif curchar == &quot;*&quot;:
      var pair = decodeArray(s[i..len(s)])
      let obj = pair[0]
      let count =  pair[1]
      i += count 
      return (obj, i)
    else:
      echo fmt&quot;Unrecognized char {curchar}&quot;
      break
</code></pre>
<a class="header" href="#preparing-commands" id="preparing-commands"><h3>Preparing commands</h3></a>
<p>In redis, commands are sent as List of <code>RedisValues</code></p>
<p>so <code>GET USER</code> is converted to <code>*2\r\n$3\r\nGET\r\n$4\r\nUSER\r\n\r\n</code></p>
<pre><code class="language-Nimrod">proc prepareCommand*(this: Redis, command: string, args:seq[string]): string =
  let cmdArgs = concat(@[command], args)
  var cmdAsRedisValues = newSeq[RedisValue]()
  for cmd in cmdArgs:
    cmdAsRedisValues.add(RedisValue(kind:vkBulkStr, bs:cmd))
  var arr = RedisValue(kind:vkArray, l: cmdAsRedisValues)

  return encode(arr)
</code></pre>
<a class="header" href="#nim-resp" id="nim-resp"><h3>nim-resp</h3></a>
<p>That day is based on <a href="https://github.com/xmonader/nim-resp">nim-resp</a> project, and on-going effort to create a redis client in Nim, it supports pipelining feature and all of the previous code. Feel free to send PRs or open issues</p>
<a class="header" href="#day-13-implementing-redis-client" id="day-13-implementing-redis-client"><h1>Day 13: Implementing Redis Client</h1></a>
<p>Today we will implement a redis client for Nim. Requires reading Day 12 to create redis parser</p>
<a class="header" href="#redisclient" id="redisclient"><h2>Redisclient</h2></a>
<p>We want to create a client to communicate with redis servers</p>
<blockquote>
<p>As library designers we should keep in mind How people are going to use our library, specially if it's doing IO Operations and we need to make decisions about what kind of APIs are we going to support (blocking or nonblocking ones) or should we duplicate the functionality for both interfaces. Lucky us Nim is pretty neat when it comes to providing async, sync interfaces for your library.</p>
</blockquote>
<a class="header" href="#what-do-we-expect-2" id="what-do-we-expect-2"><h2>What do we expect?</h2></a>
<ul>
<li>Sync APIs: blocking APIs</li>
</ul>
<pre><code class="language-Nimrod">  let con = open(&quot;localhost&quot;, 6379.Port)
  echo $con.execCommand(&quot;PING&quot;, @[])
  echo $con.execCommand(&quot;SET&quot;, @[&quot;auser&quot;, &quot;avalue&quot;])
  echo $con.execCommand(&quot;GET&quot;, @[&quot;auser&quot;])
  echo $con.execCommand(&quot;SCAN&quot;, @[&quot;0&quot;])
</code></pre>
<ul>
<li>Async APIs: Nonblocking APIs around <code>async/await</code></li>
</ul>
<pre><code class="language-Nimrod">  let con = await openAsync(&quot;localhost&quot;, 6379.Port)
  echo await con.execCommand(&quot;PING&quot;, @[])
  echo await con.execCommand(&quot;SET&quot;, @[&quot;auser&quot;, &quot;avalue&quot;])
  echo await con.execCommand(&quot;GET&quot;, @[&quot;auser&quot;])
  echo await con.execCommand(&quot;SCAN&quot;, @[&quot;0&quot;])
  echo await con.execCommand(&quot;SET&quot;, @[&quot;auser&quot;, &quot;avalue&quot;])
  echo await con.execCommand(&quot;GET&quot;, @[&quot;auser&quot;])
  echo await con.execCommand(&quot;SCAN&quot;, @[&quot;0&quot;])

  await con.enqueueCommand(&quot;PING&quot;, @[])
  await con.enqueueCommand(&quot;PING&quot;, @[])
  await con.enqueueCommand(&quot;PING&quot;, @[])
  echo await con.commitCommands()
 
</code></pre>
<ul>
<li>Pipelining</li>
</ul>
<pre><code class="language-Nimrod">  con.enqueueCommand(&quot;PING&quot;, @[])
  con.enqueueCommand(&quot;PING&quot;, @[])
  con.enqueueCommand(&quot;PING&quot;, @[])
  
  echo $con.commitCommands()
</code></pre>
<a class="header" href="#implementation-11" id="implementation-11"><h2>Implementation</h2></a>
<a class="header" href="#imports-and-constants-1" id="imports-and-constants-1"><h3>Imports and constants</h3></a>
<p>Let's starts with main imports</p>
<pre><code>import redisparser, strformat, tables, json, strutils, sequtils, hashes, net, asyncdispatch, asyncnet, os, strutils, parseutils, deques, options, net

</code></pre>
<p>Mainly</p>
<ul>
<li><code>redisparser</code> because we will be manipulating redis values so let's not decouple the parsing and transport</li>
<li><code>asyncnet, asyncdispatch</code> for async sockets APIs</li>
<li><code>net</code> for SSL and blocking APIs</li>
</ul>
<a class="header" href="#data-types-1" id="data-types-1"><h3>Data types</h3></a>
<p>Thinking of the expected APIs we talked about earlier we have some sort of client that has exactly the same operations with different blocking policies, so we can abstract it a bit</p>
<pre><code class="language-Nimrod">type
  RedisBase[TSocket] = ref object of RootObj
    socket: TSocket
    connected: bool
    timeout*: int
    pipeline*: seq[RedisValue]

</code></pre>
<p>Base class parameterized on <code>TSocket</code> that has</p>
<ul>
<li>socket: socket object that can be the blocking <code>net.Socket</code> or the nonoblocking <code>asyncnet.AsyncSocket</code></li>
<li>connected: flag to indicate the connection status</li>
<li>timeout: to timeout (raise TimeoutError) after certain amount of seconds</li>
</ul>
<pre><code class="language-Nimrod">  Redis* = ref object of RedisBase[net.Socket]
</code></pre>
<p>Here we say <code>Redis</code> is a sub type of <code>RedisBase</code> and the type of transport socket we are using is the blocking <code>net.Socket</code></p>
<pre><code class="language-Nimrod">  AsyncRedis* = ref object of RedisBase[asyncnet.AsyncSocket]
</code></pre>
<p>Same, but here we say the socket we use is non blocking of type <code>asyncnet.AsyncSocket</code></p>
<a class="header" href="#opening-connection" id="opening-connection"><h3>Opening Connection</h3></a>
<pre><code class="language-Nimrod">proc open*(host = &quot;localhost&quot;, port = 6379.Port, ssl=false, timeout=0): Redis =
  result = Redis(
    socket: newSocket(buffered = true),
  )
  result.pipeline = @[]
  result.timeout = timeout
  ## .. code omitted for supporting SSL
  result.socket.connect(host, port)
  result.connected = true
</code></pre>
<p>Here we define <code>open</code> proc the entry point to get sync redis client <code>Redis</code>. We do some initializations regarding the endpoint and the timeout and setting that on our <code>Redis</code> new object.</p>
<pre><code class="language-Nimrod">proc openAsync*(host = &quot;localhost&quot;, port = 6379.Port, ssl=false, timeout=0): Future[AsyncRedis] {.async.} =
  ## Open an asynchronous connection to a redis server.
  result = AsyncRedis(
    socket: newAsyncSocket(buffered = true),
  )
  ## .. code omitted for supporting SSL
  result.pipeline = @[]
  result.timeout = timeout
  await result.socket.connect(host, port)
  result.connected = true

</code></pre>
<p>Exactly the same thing for openAsync, but instead of returning <code>Redis</code> we return a <code>Future</code> of potential <code>AsyncRedis</code> object</p>
<a class="header" href="#executing-commands" id="executing-commands"><h3>Executing commands</h3></a>
<p>Our APIs will be created around <code>execCommand</code> proc that will send some <code>command</code> with <code>arguments</code> formatted with <code>redis</code> protocol (using the redisparser library) to a server using Our socket and then read a complete parsable <code>RedisValue</code> back to the user (using <code>readForm</code> proc)</p>
<ul>
<li>Sync version</li>
</ul>
<pre><code class="language-Nimrod">
proc execCommand*(this: Redis|AsyncRedis, command: string, args:seq[string]): RedisValue =
  let cmdArgs = concat(@[command], args)
  var cmdAsRedisValues = newSeq[RedisValue]()
  for cmd in cmdArgs:
    cmdAsRedisValues.add(RedisValue(kind:vkBulkStr, bs:cmd))
  var arr = RedisValue(kind:vkArray, l: cmdAsRedisValues)
  this.socket.send(encode(arr))
  let form = this.readForm()
  let val = decodeString(form)
  return val
</code></pre>
<ul>
<li>Async version</li>
</ul>
<pre><code class="language-Nimrod">
proc execCommandAsync*(this: Redis|AsyncRedis, command: string, args:seq[string]): Future[RedisValue] =
  let cmdArgs = concat(@[command], args)
  var cmdAsRedisValues = newSeq[RedisValue]()
  for cmd in cmdArgs:
    cmdAsRedisValues.add(RedisValue(kind:vkBulkStr, bs:cmd))
  var arr = RedisValue(kind:vkArray, l: cmdAsRedisValues)
  await this.socket.send(encode(arr))
  let form = await this.readForm()
  let val = decodeString(form)
  return val

</code></pre>
<p>It'd be very annoying to do provide duplicate procs for every single API <code>get</code> and <code>asyncGet</code> ... etc</p>
<a class="header" href="#multisync-ftw" id="multisync-ftw"><h4>Multisync FTW!</h4></a>
<p>Nim provides a very neat feature <code>multisync</code> pragma that allows us to use the <code>async</code> definition in sync scopes</p>
<p>Here is the details from <a href="https://github.com/nim-lang/Nim/blob/master/lib/pure/asyncmacro.nim#L430">nim</a></p>
<blockquote>
<p>Macro which processes async procedures into both asynchronous and synchronous procedures. The generated async procedures use the <code>async</code> macro, whereas the generated synchronous procedures simply strip off the <code>await</code> calls.</p>
</blockquote>
<pre><code class="language-Nimrod">
proc execCommand*(this: Redis|AsyncRedis, command: string, args:seq[string]): Future[RedisValue] {.multisync.} =
  let cmdArgs = concat(@[command], args)
  var cmdAsRedisValues = newSeq[RedisValue]()
  for cmd in cmdArgs:
    cmdAsRedisValues.add(RedisValue(kind:vkBulkStr, bs:cmd))
  var arr = RedisValue(kind:vkArray, l: cmdAsRedisValues)
  await this.socket.send(encode(arr))
  let form = await this.readForm()
  let val = decodeString(form)
  return val
</code></pre>
<a class="header" href="#readers" id="readers"><h3>Readers</h3></a>
<p><code>readForm</code> is the other main proc in our client. <code>readForm</code> is responsible for reading X amount of bytes from the socket until we have a complete <code>RedisValue</code> object.</p>
<ul>
<li><code>readMany</code> as the redis protocol encodes some information about the values lengths we can totally make use of that, so let's build a primitive <code>readMany</code> that reads X amount of the socket</li>
</ul>
<pre><code class="language-Nimrod">
proc readMany(this:Redis|AsyncRedis, count:int=1): Future[string] {.multisync.} =
  if count == 0:
    return &quot;&quot;
  let data = await this.receiveManaged(count)
  return data
</code></pre>
<p>Here again to make sure our code works with <code>sync</code> and <code>async</code> usages we use <code>multisync</code> if the count required is 0 we return empty string without any fancy things with the socket otherwise we delegate to the <code>receiveManaged</code> proc</p>
<ul>
<li><code>receivedManaged</code> a bit into details version on how we read the data from the socket (could be combined in the readMany proc code)</li>
</ul>
<pre><code class="language-Nimrod">proc receiveManaged*(this:Redis|AsyncRedis, size=1): Future[string] {.multisync.} =
  result = newString(size)
  when this is Redis:
    if this.timeout == 0:
      discard this.socket.recv(result, size)
    else:
      discard this.socket.recv(result, size, this.timeout)
  else:
    discard await this.socket.recvInto(addr result[0], size)
  return result
</code></pre>
<p>We check the type of <code>this</code> object using <code>when/is</code> combo to dispatch to the correct implementation (sync or async) with timeouts or not</p>
<ul>
<li><code>recv</code> has multiple versions one of them takes a <code>Timeout</code> <code>this.timeout</code> if the user wants to timeout after a while</li>
<li><code>recvInto</code> is the <code>async</code> version and doesn't support timeouts</li>
</ul>
<a class="header" href="#readform" id="readform"><h4>readForm</h4></a>
<p><code>readForm</code> is used to retrieve a complete <code>RedisValue</code> from the server using the primitives we provided like 1readMany<code>or</code>receiveManaged`</p>
<p>Remember how we decode strings into RedisValue objects?</p>
<pre><code class="language-Nimrod">  echo decodeString(&quot;*3\r\n:1\r\n:2\r\n:3\r\n\r\n&quot;)
  # # @[1, 2, 3]
  echo decodeString(&quot;+Hello, World\r\n&quot;)
  # # Hello, World
  echo decodeString(&quot;-Not found\r\n&quot;)
  # # Not found
  echo decodeString(&quot;:1512\r\n&quot;)
  # # 1512
  echo $decodeString(&quot;$32\r\nHello, World THIS IS REALLY NICE\r\n&quot;)
  # Hello, World THIS IS REALLY NICE
  echo decodeString(&quot;*2\r\n+Hello World\r\n:23\r\n&quot;)
  # @[Hello World, 23]
  echo decodeString(&quot;*2\r\n*3\r\n:1\r\n:2\r\n:3\r\n\r\n*5\r\n:5\r\n:7\r\n+Hello Word\r\n-Err\r\n$6\r\nfoobar\r\n&quot;)
  # @[@[1, 2, 3], @[5, 7, Hello Word, Err, foobar]]
  echo $decodeString(&quot;*4\r\n:51231\r\n$3\r\nfoo\r\n$-1\r\n$3\r\nbar\r\n&quot;)
  # @[51231, foo, , bar]
</code></pre>
<p>We will be doing exactly the same, but the only tricky part is we are reading from a socket and we can't move freely forward/backward without consuming data.</p>
<p>The way we were decoding strings into RedisValues was by peeking on the first character to see what type we are decoding <code>simple string</code>, <code>bulkstring</code>, <code>error</code>, <code>int</code>, <code>array</code></p>
<pre><code class="language-Nimrod">
proc readForm(this:Redis|AsyncRedis): Future[string] {.multisync.} =
  var form = &quot;&quot;
  ## code responsible of reading a complete parsable string representing RedisValue from the socket
  return form
</code></pre>
<ul>
<li>Setup the loop</li>
</ul>
<pre><code class="language-Nimrod">  while true:
    let b = await this.receiveManaged()
    form &amp;= b
    ## ...
</code></pre>
<p>as long as we aren't done reading a complete form yet we read just 1 byte and append it to the form string we will be returning (in the beginning that byte can be one of (<code>+</code>, <code>-</code>, <code>:</code>, <code>$</code>, <code>*</code>)</p>
<ul>
<li>Simple String</li>
</ul>
<pre><code class="language-Nimrod">    if b == &quot;+&quot;:
      form &amp;= await this.readStream(CRLF)
      return form
</code></pre>
<p>If the character we peeking at is <code>+</code> we read until we consume the <code>\r\n</code> <code>CRLF</code> (from redisparser library) because strings in redis protocl are contained between <code>+</code> and <code>CRLF</code></p>
<p>but wait! what's <code>readStream</code>?
It's a small proc we need to consume bytes from the socket until we reach [and consume] a certain character</p>
<pre><code class="language-Nimrod">proc readStream(this:Redis|AsyncRedis, breakAfter:string): Future[string] {.multisync.} =
  var data = &quot;&quot;
  while true:
    if data.endsWith(breakAfter):
      break
    let strRead = await this.receiveManaged()
    data &amp;= strRead
  return data
</code></pre>
<ul>
<li>Errors</li>
</ul>
<pre><code class="language-Nimrod">    elif b == &quot;-&quot;:
      form &amp;= await this.readStream(CRLF)
      return form
</code></pre>
<p>Exactly the same as <code>Simple strings</code> but we check on <code>-</code> instead of <code>+</code></p>
<ul>
<li>Ints</li>
</ul>
<pre><code class="language-Nimrod">    elif b == &quot;:&quot;:
      form &amp;= await this.readStream(CRLF)
      return form
</code></pre>
<p>Same, serialized between <code>:</code> and <code>CRLF</code></p>
<ul>
<li>Bulkstrings</li>
</ul>
<pre><code class="language-Nimrod">    elif b == &quot;$&quot;:
      let bulklenstr = await this.readStream(CRLF)
      let bulklenI = parseInt(bulklenstr.strip()) 
      form &amp;= bulklenstr
      if bulklenI == -1:
        form &amp;= CRLF

    else:
      form &amp;= await this.readMany(bulklenI)
      form &amp;= await this.readStream(CRLF)

    return form
</code></pre>
<p>From RESP page</p>
<pre><code>Bulk Strings are used in order to represent a single binary safe string up to 512 MB in length.

Bulk Strings are encoded in the following way:

A &quot;$&quot; byte followed by the number of bytes composing the string (a prefixed length), terminated by CRLF.
The actual string data.
A final CRLF.
So the string &quot;foobar&quot; is encoded as follows:

&quot;$6\r\nfoobar\r\n&quot;
When an empty string is just:

&quot;$0\r\n\r\n&quot;
RESP Bulk Strings can also be used in order to signal non-existence of a value using a special format that is used to represent a Null value. In this special format the length is -1, and there is no data, so a Null is represented as:

&quot;$-1\r\n&quot;
</code></pre>
<p>So we can have
1- <code>0</code> for empty strings <code>$0\r\n\r\n</code>:read from <code>$</code> until we consume CRLF and CRLF
2- <code>number</code> of bytes to read:  read from <code>$</code> N amounts of bytes then consume CRLF
3- <code>-1</code> for nils read from <code>$</code>  until we consume CRLF</p>
<ul>
<li>Arrays</li>
</ul>
<pre><code class="language-Nimrod">    elif b == &quot;*&quot;:
        let lenstr = await this.readStream(CRLF)
        form &amp;= lenstr
        let lenstrAsI = parseInt(lenstr.strip())
        for i in countup(1, lenstrAsI):
          form &amp;= await this.readForm()
        return form
</code></pre>
<p>Arrays can be bit tricky. To encode an array we do <code>*</code> followed by array length then <code>\r\n</code> then encode each element then end the array encoding with <code>\r\n</code></p>
<p>As the arrays encode their <code>length</code> we know how many inner <code>forms</code> or items we need to read from the socket while reading the array</p>
<a class="header" href="#pipelining" id="pipelining"><h3>Pipelining</h3></a>
<p>From redis <a href="https://redis.io/topics/pipelining">pipelining</a> page</p>
<pre><code>A Request/Response server can be implemented so that it is able to process new requests even if the client didn't already read the old responses. This way it is possible to send multiple commands to the server without waiting for the replies at all, and finally read the replies in a single step.

This is called pipelining, and is a technique widely in use since many decades. For instance many POP3 protocol implementations already supported this feature, dramatically speeding up the process of downloading new emails from the server.
Redis supports pipelining since the very early days, so whatever version you are running, you can use pipelining with Redis. This is an example using the raw netcat utility:
$ (printf &quot;PING\r\nPING\r\nPING\r\n&quot;; sleep 1) | nc localhost 6379
+PONG
+PONG
+PONG
</code></pre>
<p>So the idea we maintain a sequence of commands commands to be executed <code>enqueueCommand</code> and send them <code>commitCommands</code> and reset the <code>pipeline</code> sequence afterwards</p>
<pre><code class="language-Nimrod">
proc enqueueCommand*(this:Redis|AsyncRedis, command:string, args: seq[string]): Future[void] {.multisync.} = 
  let cmdArgs = concat(@[command], args)
  var cmdAsRedisValues = newSeq[RedisValue]()
  for cmd in cmdArgs:
    cmdAsRedisValues.add(RedisValue(kind:vkBulkStr, bs:cmd))
  var arr = RedisValue(kind:vkArray, l: cmdAsRedisValues)
  this.pipeline.add(arr)

proc commitCommands*(this:Redis|AsyncRedis) : Future[RedisValue] {.multisync.} =
  for cmd in this.pipeline:
    await this.socket.send(cmd.encode())
  var responses = newSeq[RedisValue]()
  for i in countup(0, len(this.pipeline)-1):
    responses.add(decodeString(await this.readForm()))
  this.pipeline = @[]
  return RedisValue(kind:vkArray, l:responses)

</code></pre>
<a class="header" href="#higher-level-apis" id="higher-level-apis"><h3>Higher level APIs</h3></a>
<p>are basically <code>proc</code>s around the <code>execCommand</code> proc and with using <code>multisync</code> pargma you can have them enabled for both <code>sync</code> and <code>async</code> execution</p>
<pre><code class="language-nim">proc del*(this: Redis | AsyncRedis, keys: seq[string]): Future[RedisValue] {.multisync.} =
  ## Delete a key or multiple keys
  return await this.execCommand(&quot;DEL&quot;, keys)


proc exists*(this: Redis | AsyncRedis, key: string): Future[bool] {.multisync.} =
  ## Determine if a key exists
  let val = await this.execCommand(&quot;EXISTS&quot;, @[key])
  result = val.i == 1
</code></pre>
<a class="header" href="#nim-redisclient" id="nim-redisclient"><h2>nim-redisclient</h2></a>
<p>That day is based on <a href="https://github.com/xmonader/nim-redisclient">nim-redisclient</a> project which is using some higher level API code from <a href="https://github.com/nim-lang/redis">Nim/redis</a>. Feel free to send PRs or open issues</p>
<a class="header" href="#day-14-nim-assets-bundle-your-assets-into-single-binary" id="day-14-nim-assets-bundle-your-assets-into-single-binary"><h1>Day 14: Nim Assets (bundle your assets into single binary)</h1></a>
<p>Today we will implement <code>nimassets</code> project heavily inspired by <a href="https://github.com/jteeuwen/go-bindata">go-bindata</a></p>
<a class="header" href="#nimassets" id="nimassets"><h2>nimassets</h2></a>
<p>Typically while developing projects we have assets like (icons, images, template files, css, javascript..etc) and It can be annoying to distribute them with your application or even risk losing them or misconfiguring paths or messed-up packaging script, so packaging all of them into the same binary would be an interesting option to have. these concerns were the reason to have something like <code>go-bindata</code> or  <a href="http://doc.qt.io/qt-5/resources.html">Qt resource system</a></p>
<a class="header" href="#what-do-we-expect-3" id="what-do-we-expect-3"><h2>What do we expect?</h2></a>
<ul>
<li>Having single binary that has the actually resources into the executable.</li>
<li>Generating nim file out of the <code>resources</code> we want to bundle. Maybe something like <code>nimassets -d=templatesdir -o=assetsfile.nim</code></li>
<li>Easy access to these bundled resources using <code>getAsset</code> proc</li>
</ul>
<pre><code class="language-Nimrod">import assetsfile

echo assetsfile.getAsset(&quot;templatesdir/index.html&quot;)
</code></pre>
<a class="header" href="#the-plan" id="the-plan"><h2>The plan</h2></a>
<p>So from a very highlevel</p>
<pre><code>[ Resource1 ]                                
[ Resource2 ]   -&gt; converter (nimassets) -&gt;  [Nim file Represneting the resources list]
[ Resource3 ]                                

</code></pre>
<p>The generated file should look like</p>
<pre><code class="language-Nimrod">
import os, tables, strformat, base64, ospaths

var assets = initTable[string, string]()

proc getAsset*(path: string): string = 
  result = assets[path].decode()

assets[RESOURCE1_PATH] = BASE64_ENCODE(RESOURCE1_CONTENT)
assets[RESOURCE2_PATH] = BASE64_ENCODE(RESOURCE2_CONTENT)
assets[RESOURCE3_PATH] = BASE64_ENCODE(RESOURCE3_CONTENT)
...
...
...
...

</code></pre>
<ul>
<li>We store the resource path and its base64 encoded content in <code>assets</code> table</li>
<li>We will expose 1 proc <code>getAsset</code> that takes <code>path</code> and returns the content by <code>decoding base64</code> content</li>
</ul>
<a class="header" href="#implementation-12" id="implementation-12"><h2>Implementation</h2></a>
<p>Let's go top down approach for the implementation</p>
<a class="header" href="#command-line-arguments" id="command-line-arguments"><h3>Command line arguments</h3></a>
<pre><code class="language-Nimrod">const buildBranchName* = staticExec(&quot;git rev-parse --abbrev-ref HEAD&quot;) ## \
const buildCommit* = staticExec(&quot;git rev-parse HEAD&quot;)  ## \
# const latestTag* = staticExec(&quot;git describe --abbrev=0 --tags&quot;) ## \

const versionString* = fmt&quot;0.1.0 ({buildBranchName}/{buildCommit})&quot;

proc writeHelp() = 
    echo fmt&quot;&quot;&quot;
nimassets {versionString} (Bundle your assets into nim file)
    -h | --help         : show help
    -v | --version      : show version
    -o | --output       : output filename
    -f | --fast         : faster generation
    -d | --dir          : dir to include (recursively)
&quot;&quot;&quot;

proc writeVersion() =
    echo fmt&quot;nimassets version {versionString}&quot;

proc cli*() =
  var 
    compress, fast : bool = false
    dirs = newSeq[string]()
    output = &quot;assets.nim&quot;
  
  if paramCount() == 0:
    writeHelp()
    quit(0)
  
  for kind, key, val in getopt():
    case kind
    of cmdLongOption, cmdShortOption:
        case key
        of &quot;help&quot;, &quot;h&quot;: 
            writeHelp()
            quit()
        of &quot;version&quot;, &quot;v&quot;:
            writeVersion()
            quit()
        of &quot;fast&quot;, &quot;f&quot;: fast = true
        of &quot;dir&quot;, &quot;d&quot;: dirs.add(val)
        of &quot;output&quot;, &quot;o&quot;: output = val 
        else:
          discard
    else:
      discard 
  for d in dirs:
    if not dirExists(d):
      echo fmt&quot;[-] Directory doesnt exist {d}&quot;
      quit 2 # 2 means dir doesn't exist.
  # echo fmt&quot;compress: {compress} fast: {fast} dirs:{dirs} output:{output}&quot;
  createAssetsFile(dirs, output, fast, compress)

when isMainModule:
  cli()
</code></pre>
<p>Pretty simple, we accept list of directories (using <code>-d</code> or <code>--dir</code> flag) to bundle into a nim file defined using <code>output</code> flag (<code>assets.nim</code> by default)</p>
<p><code>--fast</code> flag indicates if we should use threading or not to speed up a little
<code>compress</code> used to allow compression we will pass it always as <code>false</code></p>
<blockquote>
<p>for version information (branch and commit id) we used some git commands combined with <code>staticExec</code> to ensure these values are available at compile time</p>
</blockquote>
<a class="header" href="#createassetsfile" id="createassetsfile"><h3>createAssetsFile</h3></a>
<p>this proc is the entry to our application as it receives seq of the directories we want to bundle, the output filename, code optimization, and will make use of compress flag in the future</p>
<pre><code class="language-Nimrod">proc createAssetsFile(dirs:seq[string], outputfile=&quot;assets.nim&quot;, fast=false, compress=false) =
  var generator: proc(s:string): string
  var data = assetsFileHeader

  if fast:
    generator = generateDirAssetsSpawn
  else:
    generator = generateDirAssetsSimple

  for d in dirs:
    data &amp;= generator(d)
  
  writeFile(outputfile, data)

</code></pre>
<p>Here we write (the header of the assets file and the result of generating the bundle of each directory) to the <code>outputfile</code></p>
<p>and either we bundle files one by one (using <code>generateDirAssetsSimple</code>) or separately (using <code>generateDirAssetsSpawn</code>)</p>
<a class="header" href="#generatedirassetssimple" id="generatedirassetssimple"><h3>generateDirAssetsSimple</h3></a>
<pre><code class="language-Nimrod">proc generateDirAssetsSimple(dir:string): string =
  var key, val, valString: string

  for path in expandTilde(dir).walkDirRec():
    key = path
    val = readFile(path).encode()
    valString = &quot; \&quot;\&quot;\&quot;&quot; &amp; val &amp; &quot;\&quot;\&quot;\&quot; &quot;
    result &amp;= fmt&quot;&quot;&quot;assets.add(&quot;{path}&quot;, {valString})&quot;&quot;&quot; &amp; &quot;\n\n&quot;
</code></pre>
<p>We walk recursively on the directory using <code>walkDirRec</code> and write down the part <code>assets[RESOURECE_PATH] = ENCODE_BASE64(RESOURCE CONTENT)</code> for each file in the directory.</p>
<a class="header" href="#generatedirassetsspawn" id="generatedirassetsspawn"><h3>generateDirAssetsSpawn</h3></a>
<pre><code class="language-Nimrod">proc handleFile(path:string): string {.thread.} =
  var val, valString: string
  val = readFile(path).encode()
  valString = &quot; \&quot;\&quot;\&quot;&quot; &amp; val &amp; &quot;\&quot;\&quot;\&quot; &quot;
  result = fmt&quot;&quot;&quot;assets.add(&quot;{path}&quot;, {valString})&quot;&quot;&quot; &amp; &quot;\n\n&quot;

proc generateDirAssetsSpawn(dir: string): string = 
  var results = newSeq[FlowVar[string]]()
  for path in expandTilde(dir).walkDirRec():
    results.add(spawn handleFile(path))

  # wait till all of them are done.
  for r in results:
    result &amp;= ^r
</code></pre>
<p>the same but as <code>generateDirAssetsSimple</code> but using spawn to do generate the <code>assets table entry</code></p>
<p>And that's basically it.</p>
<a class="header" href="#nimassets-1" id="nimassets-1"><h2>nimassets</h2></a>
<p>All of the code is based on <a href="https://github.com/xmonader/nimassets">nimassets</a> project. Feel free to send a PR or report issues.</p>
<a class="header" href="#day-15-tcp-router-routing-tcp-traffic" id="day-15-tcp-router-routing-tcp-traffic"><h1>Day 15: TCP Router (Routing TCP traffic)</h1></a>
<p>Today we will implement a <code>tcp router</code> or tcp portforwarder as it works against only 1 endpoint.</p>
<a class="header" href="#what-do-we-expect-4" id="what-do-we-expect-4"><h2>What do we expect?</h2></a>
<pre><code class="language-nim">let opts = ForwardOptions(listenAddr:&quot;127.0.0.1&quot;, listenPort:11000.Port, toAddr:&quot;127.0.0.1&quot;, toPort:6379.Port)
var f = newForwarder(opts)
asyncCheck f.serve()
runForever()

</code></pre>
<p>and then you can do</p>
<pre><code>redis-client -p 11000
&gt; PING
PONG

</code></pre>
<a class="header" href="#the-plan-1" id="the-plan-1"><h2>The plan</h2></a>
<ul>
<li>Listen on <code>listenPort</code> on address <code>listenAddr</code> and accept connections.</li>
<li>On every new connection (incoming)
<ul>
<li>open a socket to <code>toPort</code> on <code>toAddr</code> (outgoing)</li>
<li>whenever data is ready on any of both ends write the data to the other one</li>
</ul>
</li>
</ul>
<a class="header" href="#how-ready" id="how-ready"><h3>How ready?</h3></a>
<p>Linux provides APIs like select, poll to <code>watch</code> or <code>monitor</code> set of file descriptors and allows you to <code>do</code> some action on whatever <code>ready</code> file descriptor for reading or writing.</p>
<blockquote>
<p>The select() function gives you a way to simultaneously check multiple sockets to see if they have data waiting to be recv()d, or if you can send() data to them without blocking, or if some exception has occurred.</p>
</blockquote>
<p>Please check <a href="https://beej.us/guide/bgnet/html/multi/selectman.html">Beej's guide to network programming</a> for more on that</p>
<a class="header" href="#imports-4" id="imports-4"><h2>Imports</h2></a>
<pre><code class="language-nim">import  strformat, tables, json, strutils, sequtils, hashes, net, asyncdispatch, asyncnet, os, strutils, parseutils, deques, options, net
</code></pre>
<a class="header" href="#types-1" id="types-1"><h2>Types</h2></a>
<p>Options for the server specifying on which address to listen and where to forward the traffic.</p>
<pre><code class="language-nim">type ForwardOptions = object
  listenAddr*: string
  listenPort*: Port
  toAddr*: string
  toPort*: Port
</code></pre>
<pre><code>type Forwarder = object of RootObj
  options*: ForwardOptions


proc newForwarder(opts: ForwardOptions): ref Forwarder =
  result = new(Forwarder)
  result.options = opts

</code></pre>
<p>Represents the server <code>the forwarder</code></p>
<p>and <code>newForwarder</code> creates a forwader and sets its options</p>
<a class="header" href="#server-setup" id="server-setup"><h2>Server setup</h2></a>
<pre><code class="language-nim">proc serve(this: ref Forwarder) {.async.} =
  var server = newAsyncSocket(buffered=false)
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(this.options.listenPort, this.options.listenAddr)
  echo fmt&quot;Started tcp server... {this.options.listenAddr}:{this.options.listenPort} &quot;
  server.listen()
  
  while true:
    let client = await server.accept()
    echo &quot;..Got connection &quot;

    asyncCheck this.processClient(client)
</code></pre>
<p>We will utilize async/await features of nim to build our server.</p>
<ul>
<li>
<p>Create a new socket with <code>newAsyncSocket</code> (make sure to set buffered to false so Nim doesn't try to read all requested data)</p>
</li>
<li>
<p><code>setSockOpts</code> allows you to make the socket reusable</p>
</li>
</ul>
<blockquote>
<p>SO_REUSEADDR is used in servers mainly because it's common that you need to restart the server for the sake of trying or changing configurations (some use SIGHUP to update the configuration as a pattern) and if there were active connections the next time you start the server will fail.</p>
</blockquote>
<ul>
<li><code>bindAddr</code> binds the server to certian address and port <code>listenAddr</code> and <code>listenPort</code></li>
<li>then we start a loop to recieve connections.</li>
<li>we should call <code>await processClient</code> right? why <code>asyncCheck processClient</code></li>
</ul>
<a class="header" href="#await-vs-asynccheck" id="await-vs-asynccheck"><h3>await vs asyncCheck</h3></a>
<ul>
<li><code>await</code> means execute that async action and <code>block</code> the execution until you get a result.</li>
<li><code>asyncCheck</code> means execute async action and <code>don't block</code> a suitable name might be <code>discard</code> or <code>discardAsync</code></li>
</ul>
<p>No we can answer the question why call <code>asyncCheck processClient</code> instead of <code>await processClient</code> is because we will block the event machine until <code>processClient</code> completely executes which defeats the purpose of concurrency and accepting/handling multiple clients.</p>
<a class="header" href="#process-a-client" id="process-a-client"><h2>Process a client</h2></a>
<a class="header" href="#establish-the-connection" id="establish-the-connection"><h3>Establish the connection</h3></a>
<pre><code class="language-nim">proc processClient(this: ref Forwarder, client: AsyncSocket) {.async.} =
  let remote = newAsyncSocket(buffered=false)
  await remote.connect(this.options.toAddr, this.options.toPort)
  ...
</code></pre>
<p>First thing is to get a socket to the endpoint where we forward the traffic defined in the <code>ForwardOptions</code> <code>toAddr</code> and <code>toPort</code></p>
<p>No we could've established a loop and reading data from the <code>client</code> socket and write it to the <code>remote</code> socket</p>
<p>Problem is we may get out of sync, sometimes the remote sends data once a client connects to it before reading anything from the client. Maybe the remote sends information like server version or some metadata or instructions on protocol and it may not we can't be sure that it's waiting on recieving data always as the first step. So what we can do is <code>watch</code> the file descriptors and whoever has data we write to the other one.</p>
<p>e.g</p>
<ul>
<li>remote has data: we read <code>recv</code> it and write <code>send</code> it to the client.</li>
<li>client has data: we read <code>recv</code> it and write <code>send</code> it to the remote.</li>
</ul>
<a class="header" href="#the-remote-has-data" id="the-remote-has-data"><h3>The remote has data</h3></a>
<pre><code class="language-nim">  proc remoteHasData() {.async.} =
    while not remote.isClosed and not remote.isClosed:
      echo &quot; in remote has data loop&quot;
      let data = await remote.recv(1024)
      echo &quot;got data: &quot; &amp; data
      await client.send(data)
    client.close()
    remote.close()
</code></pre>
<a class="header" href="#the-client-has-data" id="the-client-has-data"><h3>The client has data</h3></a>
<pre><code class="language-nim">  proc clientHasData() {.async.} =
    while not client.isClosed and not remote.isClosed:
      echo &quot;in client has data loop&quot;
      let data = await client.recv(1024)
      echo &quot;got data: &quot; &amp; data
      await remote.send(data)
    client.close()
    remote.close()
</code></pre>
<a class="header" href="#run-the-data-processors" id="run-the-data-processors"><h3>Run the data processors</h3></a>
<p>Now let's register <code>clientHasData</code> and <code>remoteHasData</code> procs to the event machine and <code>LET'S NOT BLOCK</code> on any of them (remember if you don't want to block then you need <code>asyncCheck</code>)</p>
<pre><code class="language-nim">  try:
    asyncCheck clientHasData()
    asyncCheck remoteHasData()
  except:
    echo getCurrentExceptionMsg()
</code></pre>
<p>So now our <code>processClient</code> should look like</p>
<pre><code class="language-nim">
proc processClient(this: ref Forwarder, client: AsyncSocket) {.async.} =
  let remote = newAsyncSocket(buffered=false)
  await remote.connect(this.options.toAddr, this.options.toPort)

  proc clientHasData() {.async.} =
    while not client.isClosed and not remote.isClosed:
      echo &quot;in client has data loop&quot;
      let data = await client.recv(1024)
      echo &quot;got data: &quot; &amp; data
      await remote.send(data)
    client.close()
    remote.close()

  proc remoteHasData() {.async.} =
    while not remote.isClosed and not remote.isClosed:
      echo &quot; in remote has data loop&quot;
      let data = await remote.recv(1024)
      echo &quot;got data: &quot; &amp; data
      await client.send(data)
    client.close()
    remote.close()
  
  try:
    asyncCheck clientHasData()
    asyncCheck remoteHasData()
  except:
    echo getCurrentExceptionMsg()
</code></pre>
<a class="header" href="#lets-forward-to-redis" id="lets-forward-to-redis"><h2>Let's forward to redis</h2></a>
<pre><code class="language-nim">
let opts = ForwardOptions(listenAddr:&quot;127.0.0.1&quot;, listenPort:11000.Port, toAddr:&quot;127.0.0.1&quot;, toPort:6379.Port)
var f = newForwarder(opts)
asyncCheck f.serve()
runForever()

</code></pre>
<p><code>runForever</code> begins a never ending global dispatch poll loop</p>
<p>our full code</p>
<pre><code class="language-nim"># This is just an example to get you started. A typical binary package
# uses this file as the main entry point of the application.

import  strformat, tables, json, strutils, sequtils, hashes, net, asyncdispatch, asyncnet, os, strutils, parseutils, deques, options, net

type ForwardOptions = object
  listenAddr*: string
  listenPort*: Port
  toAddr*: string
  toPort*: Port

type Forwarder = object of RootObj
  options*: ForwardOptions

proc processClient(this: ref Forwarder, client: AsyncSocket) {.async.} =
  let remote = newAsyncSocket(buffered=false)
  await remote.connect(this.options.toAddr, this.options.toPort)

  proc clientHasData() {.async.} =
    while not client.isClosed and not remote.isClosed:
      echo &quot;in client has data loop&quot;
      let data = await client.recv(1024)
      echo &quot;got data: &quot; &amp; data
      await remote.send(data)
    client.close()
    remote.close()

  proc remoteHasData() {.async.} =
    while not remote.isClosed and not remote.isClosed:
      echo &quot; in remote has data loop&quot;
      let data = await remote.recv(1024)
      echo &quot;got data: &quot; &amp; data
      await client.send(data)
    client.close()
    remote.close()
  
  try:
    asyncCheck clientHasData()
    asyncCheck remoteHasData()
  except:
    echo getCurrentExceptionMsg()

proc serve(this: ref Forwarder) {.async.} =
  var server = newAsyncSocket(buffered=false)
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(this.options.listenPort, this.options.listenAddr)
  echo fmt&quot;Started tcp server... {this.options.listenAddr}:{this.options.listenPort} &quot;
  server.listen()
  
  while true:
    let client = await server.accept()
    echo &quot;..Got connection &quot;

    asyncCheck this.processClient(client)

proc newForwarder(opts: ForwardOptions): ref Forwarder =
  result = new(Forwarder)
  result.options = opts

let opts = ForwardOptions(listenAddr:&quot;127.0.0.1&quot;, listenPort:11000.Port, toAddr:&quot;127.0.0.1&quot;, toPort:6379.Port)
var f = newForwarder(opts)
asyncCheck f.serve()
runForever()

</code></pre>
<p>This project is very simple, but helped us tackle multiple concepts like how to utilize <code>async/await</code> and <code>asyncCheck</code> interesting use cases (literally @dom96 explained it to me). Of course, It can be extended to support something like forwarding TLS traffic based on <a href="https://en.wikipedia.org/wiki/Server_Name_Indication">SNI</a> So you can serve multiple backends (with domains) using a single Public IP :)</p>
<p>Please feel free to contribute by opening PR or issue on the repo.</p>
<a class="header" href="#day-16-ascii-tables" id="day-16-ascii-tables"><h1>Day 16: Ascii Tables</h1></a>
<p>ASCII tables are everywhere, every time you issue SQL select or use tools like docker to see your beloved containers or seeing your todo list in a fancy terminal todo app</p>
<a class="header" href="#what-to-expect-5" id="what-to-expect-5"><h2>What to expect</h2></a>
<p>Being able to render tables in the terminal, control the widths and the rendering characters.</p>
<pre><code class="language-nim"> var t = newAsciiTable()
  t.tableWidth = 80
  t.setHeaders(@[&quot;ID&quot;, &quot;Name&quot;, &quot;Date&quot;])
  t.addRow(@[&quot;1&quot;, &quot;Aaaa&quot;, &quot;2018-10-2&quot;])
  t.addRow(@[&quot;2&quot;, &quot;bbvbbba&quot;, &quot;2018-10-2&quot;])
  t.addRow(@[&quot;399&quot;, &quot;CCC&quot;, &quot;1018-5-2&quot;])
  printTable(t)

</code></pre>
<pre><code>+---------------------------+---------------------------+---------------------------+
|ID                         |Name                       |Date                       |
+---------------------------+---------------------------+---------------------------+
|1                          |Aaaa                       |2018-10-2                  |
+---------------------------+---------------------------+---------------------------+
|2                          |bbvbbba                    |2018-10-2                  |
+---------------------------+---------------------------+---------------------------+
|399                        |CCC                        |1018-5-2                   |
+---------------------------+---------------------------+---------------------------+


</code></pre>
<p>or let nim decides for you</p>
<pre><code class="language-nim">  t.tableWidth = 0
  printTable(t)
</code></pre>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
+---+-------+---------+
|2  |bbvbbba|2018-10-2|
+---+-------+---------+
|399|CCC    |1018-5-2 |
+---+-------+---------+

</code></pre>
<p>or even remote the separators between the rows.</p>
<pre><code class="language-nim">+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
|2  |bbvbbba|2018-10-2|
|399|CCC    |1018-5-2 |
+---+-------+---------+
</code></pre>
<a class="header" href="#why-not-to-do-it-manually" id="why-not-to-do-it-manually"><h3>Why not to do it manually?</h3></a>
<p>Well if you want to write code like this</p>
<pre><code class="language-nim">      var widths = @[0,0,0,0]  #id, name, ports, root
      for k, v in info:
        if len($v.id) &gt; widths[0]:
          widths[0] = len($v.id)
        if len($v.name) &gt; widths[1]:
          widths[1] = len($v.name)
        if len($v.ports) &gt; widths[2]:
          widths[2] = len($v.ports)
        if len($v.root) &gt; widths[3]:
          widths[3] = len($v.root)
      
      var sumWidths = 0
      for w in widths:
        sumWidths += w
      
      echo &quot;-&quot;.repeat(sumWidths)

      let extraPadding = 5
      echo &quot;| ID&quot;  &amp; &quot; &quot;.repeat(widths[0]+ extraPadding-4) &amp; &quot;| Name&quot; &amp; &quot; &quot;.repeat(widths[1]+extraPadding-6) &amp; &quot;| Ports&quot; &amp; &quot; &quot;.repeat(widths[2]+extraPadding-6 ) &amp; &quot;| Root&quot; &amp;  &quot; &quot;.repeat(widths[3]-6)
      echo &quot;-&quot;.repeat(sumWidths)
  

      for k, v in info:
        let nroot = replace(v.root, &quot;https://hub.grid.tf/&quot;, &quot;&quot;).strip()
        echo &quot;|&quot; &amp; $v.id &amp; &quot; &quot;.repeat(widths[0]-len($v.id)-1 + extraPadding) &amp; &quot;|&quot; &amp; v.name &amp; &quot; &quot;.repeat(widths[1]-len(v.name)-1 + extraPadding) &amp; &quot;|&quot; &amp; v.ports &amp; &quot; &quot;.repeat(widths[2]-len(v.ports)+extraPadding) &amp; &quot;|&quot; &amp; nroot &amp; &quot; &quot;.repeat(widths[3]-len(v.root)+ extraPadding-2) &amp; &quot;|&quot;
        echo &quot;-&quot;.repeat(sumWidths)
      result = &quot;&quot;
</code></pre>
<p>be my guest :)</p>
<a class="header" href="#imports-5" id="imports-5"><h2>imports</h2></a>
<p>Not much, but we will deal with lots of strings</p>
<pre><code class="language-nim">import strformat, strutils

</code></pre>
<a class="header" href="#types-2" id="types-2"><h2>Types</h2></a>
<p>Let's think a bit about the entities of a Table.</p>
<p>well we have <code>Table</code>, <code>headers</code>, <code>rows</code>, <code>columns</code> and each row has a <code>cell</code></p>
<a class="header" href="#cell" id="cell"><h3>Cell</h3></a>
<pre><code class="language-nim">
type Cell* = object
  leftpad*: int
  rightpad: int
  pad*: int
  text*: string

</code></pre>
<p>Describes the Cell and we define properties like <code>leftpad</code> and <code>rightpad</code> to set the padding around the text in the cell. Also, we used <code>pad</code> general property to create equal <code>leftpad</code> and <code>rightpad</code></p>
<pre><code>proc newCell*(text: string, leftpad=1, rightpad=1, pad=0): ref Cell =
  result = new Cell
  result.pad = pad
  if pad != 0:
    result.leftpad = pad
    result.rightpad = pad
  else:
    result.leftpad = leftpad
    result.rightpad = rightpad
  result.text = text
</code></pre>
<pre><code class="language-nim">proc len*(this:ref Cell): int =
  result = this.leftpad + this.text.len + this.rightpad
</code></pre>
<p>Cell length is the length of the whitespaces in the paddings <code>left</code> and <code>right</code> + the text length.</p>
<pre><code>proc `$`*(this:ref Cell): string =
  result = &quot; &quot;.repeat(this.leftpad) &amp; this.text &amp; &quot; &quot;.repeat(this.rightpad)
</code></pre>
<p>String representation of our Cell.</p>
<pre><code>proc newCellFromAnother(another: ref Cell): ref Cell =
  result = newCell(text=another.text, leftpad=another.leftpad, rightpad=another.rightpad)

</code></pre>
<p>Little helper procedure to properties from a cell to another</p>
<a class="header" href="#table" id="table"><h3>Table</h3></a>
<p>Now let's talk a bit about the table</p>
<pre><code class="language-nim">
type AsciiTable* = object 
  rows: seq[seq[string]]
  headers: seq[ref Cell]
  rowSeparator*: char
  colSeparator*: char 
  cellEdge*: char 
  widths: seq[int]
  suggestedWidths: seq[int]
  tableWidth*: int
  separateRows*: bool
</code></pre>
<p>AsciiTable describes a table.</p>
<ul>
<li>headers makes sense to a seq of strings <code>@[&quot;id&quot;, &quot;name&quot;, ...]</code> or a list of <code>Cell</code>s. we will describe it using a seq of <code>Cell</code>.</li>
<li>tableWidth: you set the total size of the table.</li>
<li>rowSeparator: character separates rows</li>
<li>colSeparator: character separates columns</li>
<li>cellEdge: character on the edge of each cell
Remeber that's how our table looks</li>
</ul>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
+---+-------+---------+
|399|CCC    |1018-5-2 |
+---+-------+---------+

</code></pre>
<p>We see each row is separated by <code>rowSeparator</code> <code>-</code> line and <code>cellEdge</code> <code>+</code> on the edgeof every cell and the columns are separated by <code>colSeparator</code> <code>|</code></p>
<ul>
<li>separateRows property allows us to remove the separator between rows</li>
</ul>
<p>without separator</p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
|2  |bbvbbba|2018-10-2|
|399|CCC    |1018-5-2 |
+---+-------+---------+

</code></pre>
<p>with separator</p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
+---+-------+---------+
|2  |bbvbbba|2018-10-2|
+---+-------+---------+
|399|CCC    |1018-5-2 |
+---+-------+---------+
</code></pre>
<pre><code class="language-nim">proc newAsciiTable*(): ref AsciiTable =
  result = new AsciiTable
  result.rowSeparator='-'
  result.colSeparator='|'
  result.cellEdge='+'
  result.tableWidth=0
  result.separateRows=true
  result.widths = newSeq[int]()
  result.suggestedWidths = newSeq[int]()
  result.rows = newSeq[seq[string]]()
  result.headers = newSeq[ref Cell]()
</code></pre>
<p>Helper to initialize the table.</p>
<pre><code class="language-nim">proc columnsCount*(this: ref AsciiTable): int =
  result = this.headers.len
</code></pre>
<p>helper to get the number of columns.</p>
<pre><code class="language-nim">proc setHeaders*(this: ref AsciiTable, headers:seq[string]) =
  for s in headers:
    var cell = newCell(s)
    this.headers.add(cell)

proc setHeaders*(this: ref AsciiTable, headers: seq[ref Cell]) = 
  this.headers = headers

</code></pre>
<p>Allow the usage of strings directly as for headers or customized Cells</p>
<pre><code class="language-nim">proc setRows*(this: ref AsciiTable, rows:seq[seq[string]]) =
  this.rows = rows

proc addRow*(this: ref AsciiTable, row:seq[string]) =
  this.rows.add(row)

</code></pre>
<p>Helpers to add rows to the table <code>data structure</code></p>
<pre><code class="language-nim">proc printTable*(this: ref AsciiTable) =
  echo(this.render())
</code></pre>
<p>this will print the <code>rendered</code> table which is prepared using <code>render</code> proc.</p>
<pre><code class="language-nim">proc reset*(this:ref AsciiTable) =
  this.rowSeparator='-'
  this.colSeparator='|'
  this.cellEdge='+'
  this.tableWidth=0
  this.separateRows=true
  this.widths = newSeq[int]()
  this.suggestedWidths = newSedq[int]()
  this.rows = newSeq[seq[string]]()
  this.headers = newSeq[ref Cell]()
</code></pre>
<p>Resets table defaults.</p>
<a class="header" href="#rendering-the-table" id="rendering-the-table"><h4>Rendering the table.</h4></a>
<p>Let's assume for a second that <code>widths</code> property has all the information about the size of each column based on its index
e.g <code>widths =&gt; [5, 10, 20]</code> means</p>
<ul>
<li>column 0 can hold maximum of 5 char cell.</li>
<li>column 1 can hold maximum of 10 chars cell.</li>
<li>column 2 can hold maximum of 20 chars cell.</li>
</ul>
<p>the column <code>cells</code> size can't be varied so we set the size to the <code>LONGEST</code> item in the column.
it's bit tedious so we will get back to it later.</p>
<pre><code class="language-nim">proc oneLine(this: ref AsciiTable): string =
  result &amp;= this.cellEdge
  for w in this.widths:
    result &amp;= this.rowSeparator.repeat(w) &amp; this.cellEdge
  result &amp;= &quot;\n&quot;
</code></pre>
<p>oneLine helps in creating such line</p>
<pre><code>+---+-------+---------+
</code></pre>
<p>So how does it work?
1- add the <code>cellEdge</code> <code>+</code> on the left
2- add <code>colSeparator</code> <code>-</code> until you consume the size of the width of the column you are at and then add <code>cellEdge</code> again.
3- add new line. <code>\n</code></p>
<p>Steps for each width.</p>
<pre><code>+
+---+
+---+-------+
+---+-------+---------+
</code></pre>
<pre><code class="language-nim">proc render*(this: ref AsciiTable): string =
  this.calculateWidths()
</code></pre>
<p>We start by calling our magic function <code>calculateWidths</code></p>
<pre><code class="language-nim">  # top border
  result &amp;= this.oneline()
</code></pre>
<p>Generate the top border line of the table.</p>
<pre><code class="language-nim">  # headers
  for colidx, h in this.headers:
    result &amp;= this.colSeparator &amp; $h &amp; &quot; &quot;.repeat(this.widths[colidx]-len(h) )
  
  result &amp;= this.colSeparator
  result &amp;= &quot;\n&quot;
  # finish headers 

  # line after headers
</code></pre>
<p>Now the headers</p>
<pre><code>|ID |Name   |Date     |
</code></pre>
<p>So we start with <code>colSeparator</code> <code>|</code> for each header defined in <code>this.headers</code> the print the content of the header (which is a cell so we print the leftpad + text + rightpad ) and add <code>colSeparator</code> <code>|</code> to the end of the items</p>
<pre><code class="language-nim">  result &amp;= this.oneline()

</code></pre>
<p>Add another line, So our table looks like this now.</p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
</code></pre>
<pre><code class="language-nim">  # start rows
  for r in this.rows:
    # start row
    for colidx, c in r:
      let cell = newCell(c, leftpad=this.headers[colidx].leftpad, rightpad=this.headers[colidx].rightpad)
      result &amp;= this.colSeparator &amp; $cell &amp; &quot; &quot;.repeat(this.widths[colidx]-len(cell)) 
    result &amp;= this.colSeparator
    result &amp;= &quot;\n&quot;
</code></pre>
<p>Now exactly the same for each row, we get the row and print it the same way we printed the headers and follow it by a new line.</p>
<p>Our table looks like this now</p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
</code></pre>
<pre><code class="language-nim">    if this.separateRows: 
        result &amp;= this.oneLine()
    # finish row
</code></pre>
<p>Now we need to decide: are all the rows have line separating them or they don't.
In case if they have separators we finish the row by adding another <code>oneLine</code></p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
+---+-------+---------+
</code></pre>
<p>or if it doesn't have separators and we want our table to look like this in the end</p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
|2  |bbvbbba|2018-10-2|

</code></pre>
<p>we don't add <code>oneLine</code></p>
<pre><code>  # don't duplicate the finishing line if it's already printed in case of this.separateRows
  if not this.separateRows:
      result &amp;= this.oneLine()
  return result
</code></pre>
<p>if we don't separateRows we add the final <code>oneLine</code> to the table</p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
|2  |bbvbbba|2018-10-2|
+---+-------+---------+   &lt;- the final oneLine
</code></pre>
<p>if we do separateRows we shouldn't add another <code>oneLine</code> or our table will be rendered like</p>
<pre><code>+---+-------+---------+
|ID |Name   |Date     |
+---+-------+---------+
|1  |Aaaa   |2018-10-2|
+---+-------+---------+
|2  |bbvbbba|2018-10-2|
+---+-------+---------+
+---+-------+---------+
</code></pre>
<a class="header" href="#now-back-to-calculating-widths" id="now-back-to-calculating-widths"><h3>Now back to calculating widths</h3></a>
<p>Back to the magic function. To be honest, it's not magical it's just bit tedious.
So the basic idea is:</p>
<pre><code class="language-nim">proc calculateWidths(this: ref AsciiTable) =
  var colsWidths = newSeq[int]()

</code></pre>
<p>a list of column widths</p>
<pre><code>  if this.suggestedWidths.len == 0:
    for h in this.headers:
      colsWidths.add(h.len) 
  else:
    colsWidths = this.suggestedWidths
</code></pre>
<p>the user might suggest some widths via <code>suggestedWidths</code> property, so can use them for guidance.</p>
<pre><code class="language-nim">
  for row in this.rows:
    for colpos, c in row:
      var acell = newCellFromAnother(this.headers[colpos])
      acell.text = c
      if len(acell) &gt; colsWidths[colpos]:
        colsWidths[colpos] = len(acell)
</code></pre>
<p>we get the size <code>length</code> of each column by iterating on all the rows and find the <code>max</code> item (the cell with the longest size) in the position of the column in every row and that <code>max</code> will be the column width.</p>
<p>We support other options like <code>totalWidth</code> of the Table and that will make equal column sizes if the user didn't <code>suggest widths</code></p>
<pre><code class="language-nim">  let sizeForCol = (this.tablewidth/len(this.headers)).toInt()
  var lenHeaders = 0
  for w in colsWidths:
    lenHeaders += w 
</code></pre>
<p>Here we calculate the length of each header <code>equally</code> using table width specified by the user divided by the number of columns <code>headers</code></p>
<pre><code class="language-nim">  if this.tablewidth &gt; lenHeaders:
    if this.suggestedWidths.len == 0:
      for colpos, c in colsWidths:
        colsWidths[colpos] += sizeForCol - c
</code></pre>
<p>if the user didn't suggest any widths then he wants the table columns of equal length</p>
<pre><code class="language-nim">  if this.suggestedWidths.len != 0:
    var sumSuggestedWidths = 0
    for s in this.suggestedWidths:
      sumSuggestedWidths += s

    if lenHeaders &gt; sumSuggestedWidths:
      raise newException(ValueError, fmt&quot;sum of {this.suggestedWidths} = {sumSuggestedWidths} and it's less than required length {lenHeaders}&quot;)      
</code></pre>
<p>if the user suggested some widths we caculate the sum of what user suggested and check if <code>greater than</code> the calculated <code>lenHeaders</code> and if it's not we raise an exception.</p>
<pre><code class="language-nim">  this.widths = colsWidths
</code></pre>
<p>Phew! We finally set the widths property now</p>
<a class="header" href="#nim-asciitable" id="nim-asciitable"><h2>nim-asciitable</h2></a>
<p>this day is based on my project <a href="https://github.com/xmonader/nim-asciitables">nim-asciitables</a> and it's superseded by <a href="https://github.com/xmonader/nim-terminaltables">nim-terminaltables</a> which provides more customizable styles and unicode box drawing support.</p>
<a class="header" href="#day-17-nim-sonic-client-nim-and-rust-can-be-friends" id="day-17-nim-sonic-client-nim-and-rust-can-be-friends"><h1>Day 17: Nim-Sonic-Client: Nim and Rust can be friends!</h1></a>
<p><a href="https://github.com/valeriansaliou/sonic">sonic</a>  is a fast, lightweight and schema-less search backend. It ingests search texts and identifier tuples that can then be queried against in a microsecond's time, and it's implemented in rust. Sonic can be used as a simple alternative to super-heavy and full-featured search backends such as Elasticsearch in some use-cases. It is capable of normalizing natural language search queries, auto-completing a search query and providing the most relevant results for a query. Sonic is an identifier index, rather than a document index; when queried, it returns IDs that can then be used to refer to the matched documents in an external database. We use it heavily in all of our projects currently using <a href="https://github.com/xmonader/python-sonic-client">python client</a>, but we are here today to talk about nim. Please make sure to check sonic website for more info on how start the server and its configurations</p>
<a class="header" href="#what-to-expect--3" id="what-to-expect--3"><h2>What to expect ?</h2></a>
<a class="header" href="#ingest" id="ingest"><h3>Ingest</h3></a>
<p>We should be able to push data over tcp from nim to sonic</p>
<pre><code class="language-nim">    var cl = open(&quot;127.0.0.1&quot;, 1491, &quot;dmdm&quot;, SonicChannel.Ingest)
    echo $cl.execCommand(&quot;PING&quot;)

    echo cl.ping()
    echo cl.protocol
    echo cl.bufsize
    echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-1&quot;,
                  &quot;for the love of god hell&quot;)
    echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-2&quot;,
                  &quot;for the love of satan heaven&quot;)
    echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-3&quot;,
                  &quot;for the love of lorde hello&quot;)
    echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-4&quot;,
                  &quot;for the god of loaf helmet&quot;)
</code></pre>
<pre><code>PONG
true
0
0
true
2
0
true
true
true
</code></pre>
<a class="header" href="#search" id="search"><h3>Search</h3></a>
<p>We should be able to search/complete data from nim client using sonic</p>
<pre><code class="language-nim">
    var cl = open(&quot;127.0.0.1&quot;, 1491, &quot;dmdm&quot;, SonicChannel.Search)
    echo $cl.execCommand(&quot;PING&quot;)

    echo cl.ping()
    echo cl.query(&quot;wiki&quot;, &quot;articles&quot;, &quot;for&quot;)
    echo cl.query(&quot;wiki&quot;, &quot;articles&quot;, &quot;love&quot;)
    echo cl.suggest(&quot;wiki&quot;, &quot;articles&quot;, &quot;hell&quot;)
    echo cl.suggest(&quot;wiki&quot;, &quot;articles&quot;, &quot;lo&quot;)
</code></pre>
<pre><code>PONG
true
@[]
@[&quot;article-3&quot;, &quot;article-2&quot;]
@[]
@[&quot;loaf&quot;, &quot;lorde&quot;, &quot;love&quot;]

</code></pre>
<a class="header" href="#sonic-specification" id="sonic-specification"><h2>Sonic specification</h2></a>
<p>If you go to their <a href="https://github.com/valeriansaliou/sonic/blob/master/PROTOCOL.md">wire protocol page</a> you will find some examples using telnet. I'll copy some in the following section</p>
<a class="header" href="#a2-sonic-channel-uninitialized" id="a2-sonic-channel-uninitialized"><h3>2️⃣ Sonic Channel (uninitialized)</h3></a>
<ul>
<li><code>START &lt;mode&gt; &lt;password&gt;</code>: select mode to use for connection (either: <code>search</code> or <code>ingest</code>). The password is found in the <code>config.cfg</code> file at <code>channel.auth_password</code>.</li>
</ul>
<p><em>Issuing any other command — eg. <code>QUIT</code> — in this mode will abort the TCP connection, effectively resulting in a <code>QUIT</code> with the <code>ENDED not_recognized</code> response.</em></p>
<hr />
<a class="header" href="#a3-sonic-channel-search-mode" id="a3-sonic-channel-search-mode"><h3>3️⃣ Sonic Channel (Search mode)</h3></a>
<p><em>The Sonic Channel Search mode is used for querying the search index. Once in this mode, you cannot switch to other modes or gain access to commands from other modes.</em></p>
<p><strong>➡️ Available commands:</strong></p>
<ul>
<li><code>QUERY</code>: query database (syntax: <code>QUERY &lt;collection&gt; &lt;bucket&gt; &quot;&lt;terms&gt;&quot; [LIMIT(&lt;count&gt;)]? [OFFSET(&lt;count&gt;)]? [LANG(&lt;locale&gt;)]?</code>; time complexity: <code>O(1)</code> if enough exact word matches or <code>O(N)</code> if not enough exact matches where <code>N</code> is the number of alternate words tried, in practice it approaches <code>O(1)</code>)</li>
<li><code>SUGGEST</code>: auto-completes word (syntax: <code>SUGGEST &lt;collection&gt; &lt;bucket&gt; &quot;&lt;word&gt;&quot; [LIMIT(&lt;count&gt;)]?</code>; time complexity: <code>O(1)</code>)</li>
<li><code>PING</code>: ping server (syntax: <code>PING</code>; time complexity: <code>O(1)</code>)</li>
<li><code>HELP</code>: show help (syntax: <code>HELP [&lt;manual&gt;]?</code>; time complexity: <code>O(1)</code>)</li>
<li><code>QUIT</code>: stop connection (syntax: <code>QUIT</code>; time complexity: <code>O(1)</code>)</li>
</ul>
<p><strong>⏩ Syntax terminology:</strong></p>
<ul>
<li><code>&lt;collection&gt;</code>: index collection (ie. what you search in, eg. <code>messages</code>, <code>products</code>, etc.);</li>
<li><code>&lt;bucket&gt;</code>: index bucket name (ie. user-specific search classifier in the collection if you have any eg. <code>user-1, user-2, ..</code>, otherwise use a common bucket name eg. <code>generic, default, common, ..</code>);</li>
<li><code>&lt;terms&gt;</code>: text for search terms (between quotes);</li>
<li><code>&lt;count&gt;</code>: a positive integer number; set within allowed maximum &amp; minimum limits;</li>
<li><code>&lt;locale&gt;</code>: an ISO 639-3 locale code eg. <code>eng</code> for English (if set, the locale must be a valid ISO 639-3 code; if set to <code>none</code>, lexing will be disabled; if not set, the locale will be guessed from text);</li>
<li><code>&lt;manual&gt;</code>: help manual to be shown (available manuals: <code>commands</code>);</li>
</ul>
<p><em>Notice: the <code>bucket</code> terminology may confuse some Sonic users. As we are well-aware Sonic may be used in an environment where end-users may each hold their own search index in a given <code>collection</code>, we made it possible to manage per-end-user search indexes with <code>bucket</code>. If you only have a single index per <code>collection</code> (most Sonic users will), we advise you use a static generic name for your <code>bucket</code>, for instance: <code>default</code>.</em></p>
<p><strong>⬇️ Search flow example (via <code>telnet</code>):</strong></p>
<pre><code class="language-bash">T1: telnet sonic.local 1491
T2: Trying ::1...
T3: Connected to sonic.local.
T4: Escape character is '^]'.
T5: CONNECTED &lt;sonic-server v1.0.0&gt;
T6: START search SecretPassword
T7: STARTED search protocol(1) buffer(20000)
T8: QUERY messages user:0dcde3a6 &quot;valerian saliou&quot; LIMIT(10)
T9: PENDING Bt2m2gYa
T10: EVENT QUERY Bt2m2gYa conversation:71f3d63b conversation:6501e83a
T11: QUERY helpdesk user:0dcde3a6 &quot;gdpr&quot; LIMIT(50)
T12: PENDING y57KaB2d
T13: QUERY helpdesk user:0dcde3a6 &quot;law&quot; LIMIT(50) OFFSET(200)
T14: PENDING CjPvE5t9
T15: PING
T16: PONG
T17: EVENT QUERY CjPvE5t9
T18: EVENT QUERY y57KaB2d article:28d79959
T19: SUGGEST messages user:0dcde3a6 &quot;val&quot;
T20: PENDING z98uDE0f
T21: EVENT SUGGEST z98uDE0f valerian valala
T22: QUIT
T23: ENDED quit
T24: Connection closed by foreign host.
</code></pre>
<p><em>Notes on what happens:</em></p>
<ul>
<li><strong>T6:</strong> we enter <code>search</code> mode (this is required to enable <code>search</code> commands);</li>
<li><strong>T8:</strong> we query collection <code>messages</code>, in bucket for platform user <code>user:0dcde3a6</code> with search terms <code>valerian saliou</code> and a limit of <code>10</code> on returned results;</li>
<li><strong>T9:</strong> Sonic received the query and stacked it for processing with marker <code>Bt2m2gYa</code> (the marker is used to track the asynchronous response);</li>
<li><strong>T10:</strong> Sonic processed search query of T8 with marker <code>Bt2m2gYa</code> and sends 2 search results (those are conversation identifiers, that refer to a primary key in an external database);</li>
<li><strong>T11 + T13:</strong> we query collection <code>helpdesk</code> twice (in the example, this one is heavy, so processing of results takes more time);</li>
<li><strong>T17 + T18:</strong> we receive search results for search queries of T11 + T13 (this took a while!);</li>
</ul>
<hr />
<a class="header" href="#a4-sonic-channel-ingest-mode" id="a4-sonic-channel-ingest-mode"><h3>4️⃣ Sonic Channel (Ingest mode)</h3></a>
<p><em>The Sonic Channel Ingest mode is used for altering the search index (push, pop and flush). Once in this mode, you cannot switch to other modes or gain access to commands from other modes.</em></p>
<p><strong>➡️ Available commands:</strong></p>
<ul>
<li><code>PUSH</code>: Push search data in the index (syntax: <code>PUSH &lt;collection&gt; &lt;bucket&gt; &lt;object&gt; &quot;&lt;text&gt;&quot; [LANG(&lt;locale&gt;)]?</code>; time complexity: <code>O(1)</code>)</li>
<li><code>POP</code>: Pop search data from the index (syntax: <code>POP &lt;collection&gt; &lt;bucket&gt; &lt;object&gt; &quot;&lt;text&gt;&quot;</code>; time complexity: <code>O(1)</code>)</li>
<li><code>COUNT</code>: Count indexed search data (syntax: <code>COUNT &lt;collection&gt; [&lt;bucket&gt; [&lt;object&gt;]?]?</code>; time complexity: <code>O(1)</code>)</li>
<li><code>FLUSHC</code>: Flush all indexed data from a collection (syntax: <code>FLUSHC &lt;collection&gt;</code>; time complexity: <code>O(1)</code>)</li>
<li><code>FLUSHB</code>: Flush all indexed data from a bucket in a collection (syntax: <code>FLUSHB &lt;collection&gt; &lt;bucket&gt;</code>; time complexity: <code>O(N)</code> where <code>N</code> is the number of bucket objects)</li>
<li><code>FLUSHO</code>: Flush all indexed data from an object in a bucket in collection (syntax: <code>FLUSHO &lt;collection&gt; &lt;bucket&gt; &lt;object&gt;</code>; time complexity: <code>O(1)</code>)</li>
<li><code>PING</code>: ping server (syntax: <code>PING</code>; time complexity: <code>O(1)</code>)</li>
<li><code>HELP</code>: show help (syntax: <code>HELP [&lt;manual&gt;]?</code>; time complexity: <code>O(1)</code>)</li>
<li><code>QUIT</code>: stop connection (syntax: <code>QUIT</code>; time complexity: <code>O(1)</code>)</li>
</ul>
<p><strong>⏩ Syntax terminology:</strong></p>
<ul>
<li><code>&lt;collection&gt;</code>: index collection (ie. what you search in, eg. <code>messages</code>, <code>products</code>, etc.);</li>
<li><code>&lt;bucket&gt;</code>: index bucket name (ie. user-specific search classifier in the collection if you have any eg. <code>user-1, user-2, ..</code>, otherwise use a common bucket name eg. <code>generic, default, common, ..</code>);</li>
<li><code>&lt;object&gt;</code>: object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact);</li>
<li><code>&lt;text&gt;</code>: search text to be indexed (can be a single word, or a longer text; within maximum length safety limits; between quotes);</li>
<li><code>&lt;locale&gt;</code>: an ISO 639-3 locale code eg. <code>eng</code> for English (if set, the locale must be a valid ISO 639-3 code; if set to <code>none</code>, lexing will be disabled; if not set, the locale will be guessed from text);</li>
<li><code>&lt;manual&gt;</code>: help manual to be shown (available manuals: <code>commands</code>);</li>
</ul>
<p><em>Notice: the <code>bucket</code> terminology may confuse some Sonic users. As we are well-aware Sonic may be used in an environment where end-users may each hold their own search index in a given <code>collection</code>, we made it possible to manage per-end-user search indexes with <code>bucket</code>. If you only have a single index per <code>collection</code> (most Sonic users will), we advise you use a static generic name for your <code>bucket</code>, for instance: <code>default</code>.</em></p>
<p><strong>⬇️ Ingest flow example (via <code>telnet</code>):</strong></p>
<pre><code class="language-bash">T1: telnet sonic.local 1491
T2: Trying ::1...
T3: Connected to sonic.local.
T4: Escape character is '^]'.
T5: CONNECTED &lt;sonic-server v1.0.0&gt;
T6: START ingest SecretPassword
T7: STARTED ingest protocol(1) buffer(20000)
T8: PUSH messages user:0dcde3a6 conversation:71f3d63b Hey Valerian
T9: ERR invalid_format(PUSH &lt;collection&gt; &lt;bucket&gt; &lt;object&gt; &quot;&lt;text&gt;&quot;)
T10: PUSH messages user:0dcde3a6 conversation:71f3d63b &quot;Hello Valerian Saliou, how are you today?&quot;
T11: OK
T12: COUNT messages user:0dcde3a6
T13: RESULT 43
T14: COUNT messages user:0dcde3a6 conversation:71f3d63b
T15: RESULT 1
T16: FLUSHO messages user:0dcde3a6 conversation:71f3d63b
T17: RESULT 1
T18: FLUSHB messages user:0dcde3a6
T19: RESULT 42
T20: PING
T21: PONG
T22: QUIT
T23: ENDED quit
T24: Connection closed by foreign host.
</code></pre>
<p><em>Notes on what happens:</em></p>
<ul>
<li><strong>T6:</strong> we enter <code>ingest</code> mode (this is required to enable <code>ingest</code> commands);</li>
<li><strong>T8:</strong> we try to push text <code>Hey Valerian</code> to the index, in collection <code>messages</code>, bucket <code>user:0dcde3a6</code> and object <code>conversation:71f3d63b</code> (the syntax that was used is invalid);</li>
<li><strong>T9:</strong> Sonic refuses the command we issued in T8, and provides us with the correct command format (notice that <code>&lt;text&gt;</code> should be quoted);</li>
<li><strong>T10:</strong> we attempt to push another text in the same collection, bucket and object as in T8;</li>
<li><strong>T11:</strong> this time, our push command in T10 was valid (Sonic acknowledges the push commit to the search index);</li>
<li><strong>T12:</strong> we count the number of indexed terms in collection <code>messages</code> and bucket <code>user:0dcde3a6</code>;</li>
<li><strong>T13:</strong> there are 43 terms (ie. words) in index for query in T12;</li>
<li><strong>T18:</strong> we flush all index data from collection <code>messages</code> and bucket <code>user:0dcde3a6</code>;</li>
<li><strong>T19:</strong> 42 terms have been flushed from index for command in T18;</li>
</ul>
<hr />
<a class="header" href="#a5-sonic-channel-control-mode" id="a5-sonic-channel-control-mode"><h3>5️⃣ Sonic Channel (Control mode)</h3></a>
<p><em>The Sonic Channel Control mode is used for administration purposes. Once in this mode, you cannot switch to other modes or gain access to commands from other modes.</em></p>
<p><strong>➡️ Available commands:</strong></p>
<ul>
<li><code>TRIGGER</code>: trigger an action (syntax: <code>TRIGGER [&lt;action&gt;]? [&lt;data&gt;]?</code>; time complexity: <code>O(1)</code>)</li>
<li><code>INFO</code>: get server information (syntax: <code>INFO</code>; time complexity: <code>O(1)</code>)</li>
<li><code>PING</code>: ping server (syntax: <code>PING</code>; time complexity: <code>O(1)</code>)</li>
<li><code>HELP</code>: show help (syntax: <code>HELP [&lt;manual&gt;]?</code>; time complexity: <code>O(1)</code>)</li>
<li><code>QUIT</code>: stop connection (syntax: <code>QUIT</code>; time complexity: <code>O(1)</code>)</li>
</ul>
<p><strong>⏩ Syntax terminology:</strong></p>
<ul>
<li><code>&lt;action&gt;</code>: action to be triggered (available actions: <code>consolidate</code>, <code>backup</code>, <code>restore</code>);</li>
<li><code>&lt;data&gt;</code>: additional data to provide to the action (required for: <code>backup</code>, <code>restore</code>);</li>
<li><code>&lt;manual&gt;</code>: help manual to be shown (available manuals: <code>commands</code>);</li>
</ul>
<p><strong>⬇️ Control flow example (via <code>telnet</code>):</strong></p>
<pre><code class="language-bash">T1: telnet sonic.local 1491
T2: Trying ::1...
T3: Connected to sonic.local.
T4: Escape character is '^]'.
T5: CONNECTED &lt;sonic-server v1.0.0&gt;
T6: START control SecretPassword
T7: STARTED control protocol(1) buffer(20000)
T8: TRIGGER consolidate
T9: OK
T10: PING
T11: PONG
T12: QUIT
T13: ENDED quit
T14: Connection closed by foreign host.
</code></pre>
<p><em>Notes on what happens:</em></p>
<ul>
<li><strong>T6:</strong> we enter <code>control</code> mode (this is required to enable <code>control</code> commands);</li>
<li><strong>T8:</strong> we trigger a database consolidation (instead of waiting for the next automated consolidation tick);</li>
</ul>
<a class="header" href="#implementation-13" id="implementation-13"><h2>Implementation</h2></a>
<a class="header" href="#imports-6" id="imports-6"><h3>imports</h3></a>
<p>these are the imports that we will use because we will be dealing with networks, some data parsing, .. etc</p>
<pre><code class="language-nim">import strformat, tables, json, strutils, sequtils, hashes, net, asyncdispatch, asyncnet, os, strutils, parseutils, deques, options, net
</code></pre>
<a class="header" href="#types-3" id="types-3"><h3>Types</h3></a>
<p>As we said earlier there're three channels</p>
<pre><code class="language-nim">type 
  SonicChannel* {.pure.} = enum
   Ingest
   Search
   Control
</code></pre>
<p>Generic sonic exception</p>
<pre><code class="language-nim">type 
  SonicServerError = object of Exception
</code></pre>
<p>Now for the base connection</p>
<pre><code class="language-nim">type
  SonicBase[TSocket] = ref object of RootObj
   socket: TSocket
   host: string
   port: int
   password: string
   connected: bool
   timeout*: int
   protocol*: int
   bufSize*: int
   channel*: SonicChannel

  Sonic* = ref object of SonicBase[net.Socket]
  AsyncSonic* = ref object of SonicBase[asyncnet.AsyncSocket]
</code></pre>
<p>we require</p>
<ul>
<li>host: sonic server running on</li>
<li>password: for sonic server</li>
<li>connected: flag for connected or none</li>
<li>timeout: timeout in seconds</li>
<li>protocol: information sent to us on connecting to sonic server</li>
<li>bufsize: how big is the data buffer u can use</li>
<li>channel: to indicate the current mode.</li>
</ul>
<a class="header" href="#helpers" id="helpers"><h3>Helpers</h3></a>
<pre><code class="language-nim">
proc quoteText(text:string): string =
  ## Quote text and normalize it in sonic protocol context.
  ##  - text str  text to quote/escape
  ##  Returns:
  ##    str  quoted text

  return '&quot;' &amp; text.replace('&quot;', '\&quot;').replace(&quot;\r\n&quot;, &quot;&quot;) &amp; '&quot;'
</code></pre>
<p>quoteText used to escape quotes and replace newline</p>
<pre><code class="language-nim">proc isError(response: string): bool =
  ## Check if the response is Error or not in sonic context.
  ## Errors start with `ERR`
  ##  - response   response string
  ##  Returns:
  ##    bool  true if response is an error.

  response.startsWith(&quot;ERR &quot;)
</code></pre>
<p>isError checks if the response represents and error</p>
<pre><code class="language-nim">proc raiseForError(response:string): string =
  ## Raise SonicServerError in case of error response.
  ##  - response message to check if it's error or not.
  ##  Returns:
  ##    str the response message
  if isError(response):
    raise newException(SonicServerError, response)
  return response
</code></pre>
<p>raiseError a short circuit for raising errors if response is an errror or returning response</p>
<a class="header" href="#making-a-connection" id="making-a-connection"><h3>Making a connection</h3></a>
<pre><code class="language-nim">proc open*(host = &quot;localhost&quot;, port = 1491, password=&quot;&quot;, channel:SonicChannel, ssl=false, timeout=0): Sonic =
  result = Sonic(
   socket: newSocket(buffered = true),
   host: host,
   port: port,
   password: password,
   channel: channel
  )
  result.timeout = timeout
  result.channel = channel
  when defined(ssl):
   if ssl == true:
     SSLifySonicConnectionNoVerify(result)
  result.socket.connect(host, port.Port)

  result.startSession()

proc openAsync*(host = &quot;localhost&quot;, port = 1491, password=&quot;&quot;, channel:SonicChannel, ssl=false, timeout=0): Future[AsyncSonic] {.async.} =
  ## Open an asynchronous connection to a Sonic server.
  result = AsyncSonic(
   socket: newAsyncSocket(buffered = true),
   channel: channel
  )
  when defined(ssl):
   if ssl == true:
     SSLifySonicConnectionNoVerify(result)
  result.timeout = timeout
  await result.socket.connect(host, port.Port)
  await result.startSession()

</code></pre>
<p>Here we support to APIs async/sync APIs for opening connection and as soon as we do the connection we call <code>startSession</code></p>
<a class="header" href="#startsession" id="startsession"><h3>startSession</h3></a>
<pre><code class="language-nim">
proc startSession*(this:Sonic|AsyncSonic): Future[void] {.multisync.} =
  let resp = await this.socket.recvLine()

  if &quot;CONNECTED&quot; in resp:
   this.connected = true

  var channelName = &quot;&quot;
  case this.channel:
   of SonicChannel.Ingest:  channelName = &quot;ingest&quot;
   of SonicChannel.Search:  channelName = &quot;search&quot;
   of SonicChannel.COntrol: channelName = &quot;control&quot;

  let msg = fmt&quot;START {channelName} {this.password} \r\n&quot;
  await this.socket.send(msg)  #### start
  discard await this.socket.recvLine()  #### started. FIXME extract protocol bufsize
  ## TODO: this.parseSessionMeta(line)
</code></pre>
<ul>
<li>we use multisync pragma to support async, sync APIs (check redisclient chapter for more info).
according to wire protocol we just send the raw string <code>START</code> <code>SPACE</code> <code>CHANNEL_NAME</code> <code>SONIC_PASSWORD</code> and terminate that with <code>\r\n</code></li>
<li>when we recieve data we should parse protocol version and the bufsize and set it in our SonicClient <code>this</code></li>
</ul>
<a class="header" href="#sendingreceiving-data" id="sendingreceiving-data"><h3>Sending/Receiving data</h3></a>
<pre><code class="language-nim">proc receiveManaged*(this:Sonic|AsyncSonic, size=1): Future[string] {.multisync.} =
  when this is Sonic:
   if this.timeout == 0:
     result = this.socket.recvLine()
   else:
     result = this.socket.recvLine(timeout=this.timeout)
  else:
   result = await this.socket.recvLine()

  result = raiseForError(result.strip())

proc execCommand*(this: Sonic|AsyncSonic, command: string, args:seq[string]): Future[string] {.multisync.} =
  let cmdArgs = concat(@[command], args)
  let cmdStr = join(cmdArgs, &quot; &quot;).strip()
  await this.socket.send(cmdStr &amp; &quot;\r\n&quot;)
  result = await this.receiveManaged()

proc execCommand*(this: Sonic|AsyncSonic, command: string): Future[string] {.multisync.} =
  result = await this.execCommand(command, @[&quot;&quot;])

</code></pre>
<p>here we have couple helpers to send data on the wire <code>execCommand</code> and receiving data <code>receiveManaged</code></p>
<ul>
<li>we only support timeout for sync client (there's a <a href="https://nim-lang.org/docs/asyncdispatch.html#withTimeout%2CFuture%5BT%5D%2Cint">withTimeout</a> for async the user can try to implement )</li>
</ul>
<p>Now we have everything we need to interact with sonic server, but not with userfriendly API, we can do better by converting the results to nim data structures or booleans when suitable</p>
<a class="header" href="#user-friendly-apis" id="user-friendly-apis"><h3>User-friendly APIs</h3></a>
<a class="header" href="#ping" id="ping"><h4>Ping</h4></a>
<p>checks the server endpoint</p>
<pre><code class="language-nim">proc ping*(this: Sonic|AsyncSonic): Future[bool] {.multisync.} =
  ## Send ping command to the server
  ## Returns:
  ## bool  True if successfully reaching the server.
  result = (await this.execCommand(&quot;PING&quot;)) == &quot;PONG&quot;
</code></pre>
<a class="header" href="#quit" id="quit"><h4>Quit</h4></a>
<p>Ends the connection</p>
<pre><code class="language-nim">proc quit*(this: Sonic|AsyncSonic): Future[string] {.multisync.} =
   ## Quit the channel and closes the connection.
   result = await this.execCommand(&quot;QUIT&quot;)
   this.socket.close()
</code></pre>
<a class="header" href="#push" id="push"><h4>Push</h4></a>
<p>Pushes search data into the index</p>
<pre><code class="language-nim">proc push*(this: Sonic|AsyncSonic, collection, bucket, objectName, text: string, lang=&quot;&quot;): Future[bool] {.multisync.} =
   ## Push search data in the index
   ##   - collection: index collection (ie. what you search in, eg. messages, products, etc.)
   ##   - bucket: index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
   ##   - objectName: object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
   ##   - text: search text to be indexed can be a single word, or a longer text; within maximum length safety limits
   ##   - lang: ISO language code
   ##   Returns:
   ##     bool  True if search data are pushed in the index. 
   var langString = &quot;&quot;
   if lang != &quot;&quot;:
     langString = fmt&quot;LANG({lang})&quot;
   let text = quoteText(text)
   result = (await this.execCommand(&quot;PUSH&quot;, @[collection, bucket, objectName, text, langString]))==&quot;OK&quot;


</code></pre>
<a class="header" href="#pop" id="pop"><h4>Pop</h4></a>
<p>Pops search data from the index</p>
<pre><code class="language-nim">proc pop*(this: Sonic|AsyncSonic, collection, bucket, objectName, text: string): Future[int] {.multisync.} =
   ## Pop search data from the index
   ##   - collection: index collection (ie. what you search in, eg. messages, products, etc.)
   ##   - bucket: index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
   ##   - objectName: object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
   ##   - text: search text to be indexed can be a single word, or a longer text; within maximum length safety limits
   ##   Returns:
   ##     int 
   let text = quoteText(text)
   let resp = await this.execCommand(&quot;POP&quot;, @[collection, bucket, objectName, text])
   result = resp.split()[^1].parseInt()
</code></pre>
<a class="header" href="#count" id="count"><h4>Count</h4></a>
<p>Count the indexed data</p>
<pre><code class="language-nim">proc count*(this: Sonic|AsyncSonic, collection, bucket, objectName: string): Future[int] {.multisync.} =
   ## Count indexed search data
   ##   - collection: index collection (ie. what you search in, eg. messages, products, etc.)
   ##   - bucket: index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
   ##   - objectName: object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
   ## Returns:
   ## int  count of index search data.

   var bucketString = &quot;&quot;
   if bucket != &quot;&quot;:
     bucketString = bucket
   var objectNameString = &quot;&quot;
   if objectName != &quot;&quot;:
     objectNameString = objectName
   result = parseInt(await this.execCommand(&quot;COUNT&quot;, @[collection, bucket, objectName]))

</code></pre>
<a class="header" href="#flush" id="flush"><h4>flush</h4></a>
<p>Generic flush to be called from flushCollection, flushBucket, flushObject</p>
<pre><code class="language-nim">proc flush*(this: Sonic|AsyncSonic, collection: string, bucket=&quot;&quot;, objectName=&quot;&quot;): Future[int] {.multisync.} =
   ## Flush indexed data in a collection, bucket, or in an object.
   ##   - collection: index collection (ie. what you search in, eg. messages, products, etc.)
   ##   - bucket: index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
   ##   - objectName: object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
   ##   Returns:
   ##     int  number of flushed data
   if bucket == &quot;&quot; and objectName==&quot;&quot;:
      result = await this.flushCollection(collection)
   elif bucket != &quot;&quot; and objectName == &quot;&quot;:
      result = await this.flushBucket(collection, bucket)
   elif objectName != &quot;&quot; and bucket != &quot;&quot;:
      result = await this.flushObject(collection, bucket, objectName)
</code></pre>
<a class="header" href="#flushcollection" id="flushcollection"><h4>flushCollection</h4></a>
<p>Flushes all the indexed data from a collection</p>
<pre><code class="language-nim">proc flushCollection*(this: Sonic|AsyncSonic, collection: string): Future[int] {.multisync.} =
   ## Flush all indexed data from a collection
   ##  - collection index collection (ie. what you search in, eg. messages, products, etc.)
   ##   Returns:
   ##     int  number of flushed data
   result = (await this.execCommand(&quot;FLUSHC&quot;, @[collection])).parseInt
</code></pre>
<a class="header" href="#flushbucket" id="flushbucket"><h4>flushBucket</h4></a>
<p>flushes all indexd data from a bucket in a collection</p>
<pre><code class="language-nim">proc flushBucket*(this: Sonic|AsyncSonic, collection, bucket: string): Future[int] {.multisync.} =
   ## Flush all indexed data from a bucket in a collection
   ##   - collection: index collection (ie. what you search in, eg. messages, products, etc.)
   ##   - bucket: index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
   ##   Returns:
   ##    int  number of flushed data
   result = (await this.execCommand(&quot;FLUSHB&quot;, @[collection, bucket])).parseInt
</code></pre>
<a class="header" href="#flushobject" id="flushobject"><h4>flushObject</h4></a>
<p>Flushes all indexed data from an object in a bucket in collection</p>
<pre><code class="language-nim">proc flushObject*(this: Sonic|AsyncSonic, collection, bucket, objectName: string): Future[int] {.multisync.} =
   ## Flush all indexed data from an object in a bucket in collection
   ##   - collection: index collection (ie. what you search in, eg. messages, products, etc.)
   ##   - bucket: index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
   ##   - objectName: object identifier that refers to an entity in an external database, where the searched object is stored (eg. you use Sonic to index CRM contacts by name; full CRM contact data is stored in a MySQL database; in this case the object identifier in Sonic will be the MySQL primary key for the CRM contact)
   ##   Returns:
   ##     int  number of flushed data
   result = (await this.execCommand(&quot;FLUSHO&quot;, @[collection, bucket, objectName])).parseInt
</code></pre>
<a class="header" href="#query" id="query"><h4>Query</h4></a>
<p>Queries sonic and returns a list of results.</p>
<pre><code class="language-nim">proc query*(this: Sonic|AsyncSonic, collection, bucket, terms: string, limit=10, offset: int=0, lang=&quot;&quot;): Future[seq[string]] {.multisync.} =
  ## Query the database
  ##  - collection index collection (ie. what you search in, eg. messages, products, etc.)
  ##  - bucket index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
  ##  - terms text for search terms
  ##  - limit a positive integer number; set within allowed maximum &amp; minimum limits
  ##  - offset a positive integer number; set within allowed maximum &amp; minimum limits
  ##  - lang an ISO 639-3 locale code eg. eng for English (if set, the locale must be a valid ISO 639-3 code; if not set, the locale will be guessed from text).
  ##  Returns:
  ##    list  list of objects ids.
  let limitString = fmt&quot;LIMIT({limit})&quot;
  var langString = &quot;&quot;
  if lang != &quot;&quot;:
   langString = fmt&quot;LANG({lang})&quot;
  let offsetString = fmt&quot;OFFSET({offset})&quot;

  let termsString = quoteText(terms)
  discard await this.execCommand(&quot;QUERY&quot;, @[collection, bucket, termsString, limitString, offsetString, langString])
  let resp = await this.receiveManaged()
  result = resp.splitWhitespace()[3..^1]
</code></pre>
<a class="header" href="#suggest" id="suggest"><h4>Suggest</h4></a>
<p>autocompletes a word using a collection and a bucket.</p>
<pre><code class="language-nim">proc suggest*(this: Sonic|AsyncSonic, collection, bucket, word: string, limit=10): Future[seq[string]] {.multisync.} =
   ## auto-completes word.
   ##   - collection index collection (ie. what you search in, eg. messages, products, etc.)
   ##   - bucket index bucket name (ie. user-specific search classifier in the collection if you have any eg. user-1, user-2, .., otherwise use a common bucket name eg. generic, procault, common, ..)
   ##   - word word to autocomplete
   ##   - limit a positive integer number; set within allowed maximum &amp; minimum limits (procault: {None})
   ##   Returns:
   ##     list list of suggested words.
   var limitString = fmt&quot;LIMIT({limit})&quot; 
   let wordString = quoteText(word)
   discard await this.execCommand(&quot;SUGGEST&quot;, @[collection, bucket, wordString, limitString])
   let resp = await this.receiveManaged()
   result = resp.splitWhitespace()[3..^1]


</code></pre>
<a class="header" href="#test-code-to-use" id="test-code-to-use"><h3>Test code to use</h3></a>
<pre><code class="language-nim">when isMainModule:

  proc testIngest() =
   var cl = open(&quot;127.0.0.1&quot;, 1491, &quot;dmdm&quot;, SonicChannel.Ingest)
   echo $cl.execCommand(&quot;PING&quot;)

   echo cl.ping()
   echo cl.protocol
   echo cl.bufsize
   echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-1&quot;,
              &quot;for the love of god hell&quot;)
   echo cl.pop(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-1&quot;,
              &quot;for the love of god hell&quot;)
   echo cl.pop(&quot;wikis&quot;, &quot;articles&quot;, &quot;article-1&quot;,
              &quot;for the love of god hell&quot;)
   echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-2&quot;,
              &quot;for the love of satan heaven&quot;)
   echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-3&quot;,
              &quot;for the love of lorde hello&quot;)
   echo cl.push(&quot;wiki&quot;, &quot;articles&quot;, &quot;article-4&quot;,
              &quot;for the god of loaf helmet&quot;)

  proc testSearch() =

   var cl = open(&quot;127.0.0.1&quot;, 1491, &quot;dmdm&quot;, SonicChannel.Search)
   echo $cl.execCommand(&quot;PING&quot;)

   echo cl.ping()
   echo cl.query(&quot;wiki&quot;, &quot;articles&quot;, &quot;for&quot;)
   echo cl.query(&quot;wiki&quot;, &quot;articles&quot;, &quot;love&quot;)
   echo cl.suggest(&quot;wiki&quot;, &quot;articles&quot;, &quot;hell&quot;)
   echo cl.suggest(&quot;wiki&quot;, &quot;articles&quot;, &quot;lo&quot;)

  proc testControl() =
   var cl = open(&quot;127.0.0.1&quot;, 1491, &quot;dmdm&quot;, SonicChannel.Control)
   echo $cl.execCommand(&quot;PING&quot;)

   echo cl.ping()
   echo cl.trigger(&quot;consolidate&quot;)


  testIngest()
  testSearch()
  testControl()

</code></pre>
<p>Code is available on <a href="https://github.com/xmonader/nim-sonic-client">xmonader/nim-sonic-client</a>. Feel free to send me a PR or open an issue.</p>
<a class="header" href="#day-18-from-a-socket-to-a-webframework" id="day-18-from-a-socket-to-a-webframework"><h1>Day 18: From a socket to a Webframework</h1></a>
<p>Today we will be focusing on building a webframework starting from a socket :)</p>
<a class="header" href="#what-to-expect-6" id="what-to-expect-6"><h2>What to expect</h2></a>
<pre><code class="language-nim">proc main() =
    var router = newRouter()



    let loggingMiddleware = proc(request: var Request): (ref Response, bool) =
      let path = request.path
      let headers = request.headers
      echo &quot;===============================&quot;
      echo &quot;from logger handler&quot;
      echo &quot;path: &quot; &amp; path
      echo &quot;headers: &quot; &amp; $headers
      echo &quot;===============================&quot;
      return (newResponse(), true)

    let trimTrailingSlash = proc(request: var Request): (ref Response, bool) =
      let path = request.path
      if path.endswith(&quot;/&quot;):
        request.path = path[0..^2]

      echo &quot;===============================&quot;
      echo &quot;from slash trimmer &quot;
      echo &quot;path was : &quot; &amp; path
      echo &quot;path: &quot; &amp; request.path
      echo &quot;===============================&quot;
      return (newResponse(), true)
      
    proc handleHello(req:var Request): ref Response =
      result = newResponse()
      result.code = Http200
      result.content = &quot;hello world from handler /hello&quot; &amp; $req 
    router.addRoute(&quot;/hello&quot;, handleHello)

    let assertJwtFieldExists =  proc(request: var Request): (ref Response, bool) =
        echo $request.headers
        let jwtHeaderVals = request.headers.getOrDefault(&quot;jwt&quot;, @[&quot;&quot;])
        let jwt = jwtHeaderVals[0]
        echo &quot;================\n\njwt middleware&quot;
        if jwt.len != 0:
          echo fmt&quot;bye bye {jwt} &quot;
        else:
          echo fmt&quot;sure bye but i didn't get ur name&quot;
        echo &quot;===================\n\n&quot;
        return (newResponse(), true)

    router.addRoute(&quot;/bye&quot;, handleHello, HttpGet, @[assertJwtFieldExists])
    
    proc handleGreet(req:var Request): ref Response =
      result = newResponse()
      result.code = Http200
      result.content = &quot;generic greet&quot; &amp; $req 

        
    router.addRoute(&quot;/greet&quot;, handleGreet, HttpGet, @[])
    router.addRoute(&quot;/greet/:username&quot;, handleGreet, HttpGet, @[])
    router.addRoute(&quot;/greet/:first/:second/:lang&quot;, handleGreet, HttpGet, @[])

    let opts = ServerOptions(address:&quot;127.0.0.1&quot;, port:9000.Port)
    var s = newServy(opts, router, @[loggingMiddleware, trimTrailingSlash])
    asyncCheck s.serve()
    echo &quot;servy started...&quot;
    runForever()
  
  main()

</code></pre>
<a class="header" href="#defining-a-handler-and-wiring-to-to-a-pattern-or-more" id="defining-a-handler-and-wiring-to-to-a-pattern-or-more"><h3>defining a handler and wiring to to a pattern or more</h3></a>
<pre><code class="language-nim">    proc handleHello(req:var Request): ref Response =
      result = newResponse()
      result.code = Http200
      result.content = &quot;hello world from handler /hello&quot; &amp; $req 
    router.addRoute(&quot;/hello&quot;, handleHello)

    proc handleGreet(req:var Request): ref Response =
      result = newResponse()
      result.code = Http200
      result.content = &quot;generic greet&quot; &amp; $req 

    router.addRoute(&quot;/greet&quot;, handleGreet, HttpGet, @[])
    router.addRoute(&quot;/greet/:username&quot;, handleGreet, HttpGet, @[])
    router.addRoute(&quot;/greet/:first/:second/:lang&quot;, handleGreet, HttpGet, @[])


</code></pre>
<a class="header" href="#definingregistering-middlewares-on-the-server-globally" id="definingregistering-middlewares-on-the-server-globally"><h3>defining/registering middlewares on the server globally</h3></a>
<pre><code class="language-nim">    let loggingMiddleware = proc(request: var Request): (ref Response, bool) =
      let path = request.path
      let headers = request.headers
      echo &quot;===============================&quot;
      echo &quot;from logger handler&quot;
      echo &quot;path: &quot; &amp; path
      echo &quot;headers: &quot; &amp; $headers
      echo &quot;===============================&quot;
      return (newResponse(), true)

    let trimTrailingSlash = proc(request: var Request): (ref Response, bool) =
      let path = request.path
      if path.endswith(&quot;/&quot;):
        request.path = path[0..^2]

      echo &quot;===============================&quot;
      echo &quot;from slash trimmer &quot;
      echo &quot;path was : &quot; &amp; path
      echo &quot;path: &quot; &amp; request.path
      echo &quot;===============================&quot;
      return (newResponse(), true)

    var s = newServy(opts, router, @[loggingMiddleware, trimTrailingSlash])


</code></pre>
<a class="header" href="#defining-middlewares-request-filters-on-certain-routes" id="defining-middlewares-request-filters-on-certain-routes"><h3>defining middlewares (request filters on certain routes)</h3></a>
<pre><code class="language-nim">    router.addRoute(&quot;/bye&quot;, handleHello, HttpGet, @[assertJwtFieldExists])
</code></pre>
<p>Sounds like a lot. Let's get to it.</p>
<a class="header" href="#implementation-14" id="implementation-14"><h2>Implementation</h2></a>
<a class="header" href="#the-big-picture" id="the-big-picture"><h3>The big picture</h3></a>
<pre><code class="language-nim">

proc newServy(options: ServerOptions, router:ref Router, middlewares:seq[MiddlewareFunc]): ref Servy =
  result = new Servy
  result.options = options
  result.router = router
  result.middlewares = middlewares

  result.sock = newAsyncSocket()
  result.sock.setSockOpt(OptReuseAddr, true)
</code></pre>
<p>we have a server listening on a socket/address (should be configurable) and has a router that knows which pattern should be handled by which handler and a set of middlewares to be used.</p>
<pre><code class="language-nim">proc serve(s: ref Servy) {.async.} =
  s.sock.bindAddr(s.options.port)
  s.sock.listen()
  while true:
    let client = await s.sock.accept()
    asyncCheck s.handleClient(client)

  runForever()

</code></pre>
<p>we receive a connection and pass it to <code>handleClient</code> proc</p>
<pre><code class="language-nim">proc handleClient(s: ref Servy, client: AsyncSocket) {.async.} =
  ## code to read request from the user
  var req = await s.parseRequestFromConnection(client)
  
  ...
  echo &quot;received request from client: &quot; &amp; $req

  ## code to get the route handler
  let (routeHandler, params) = s.router.getByPath(req.path)
  req.urlParams = params
  let handler = routeHandler.handlerFunc

  ..
  ## call the handler and return response in valid http protocol format
  let resp = handler(req)
  echo &quot;reached the handler safely.. and executing now.&quot;
  await client.send(resp.format())
  echo $req.formData

</code></pre>
<p>handleClient reads the data from the wire in <a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP protocol</a> and finds the route or requested path handler and then formats a valid http response and write it on the wire.
Cool? Awesome!</p>
<a class="header" href="#example-http-requests-and-responses" id="example-http-requests-and-responses"><h3>Example HTTP requests and responses</h3></a>
<p>when you execute <code>curl httpbin.org/get -v</code> the following (http formatted request) is sent to <code>httpbin.org</code> webserver</p>
<pre><code>GET /get HTTP/1.1
Host: httpbin.org
User-Agent: curl/7.62.0-DEV
</code></pre>
<p>That is called a <code>Request</code> that has a request line <code>METHOD PATH HTTPVERSION</code> e.g <code>GET /get HTTP/1.1</code>. Followed by a list of headers <code>lines with colon in it</code> representing key values
e.g</p>
<ul>
<li><code>Host: httpbin.org</code> a header is a line of <code>Key: value</code></li>
<li><code>User-Agent: curl/7.62.0-DEV</code> a header indicating the client type</li>
</ul>
<p>As soon as the server receives that request it'll handle it as it was told to</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: application/json
Date: Mon, 21 Oct 2019 18:28:13 GMT
Server: nginx
Content-Length: 206

{
  &quot;args&quot;: {}, 
  &quot;headers&quot;: {
    &quot;Accept&quot;: &quot;*/*&quot;, 
    &quot;Host&quot;: &quot;httpbin.org&quot;, 
    &quot;User-Agent&quot;: &quot;curl/7.62.0-DEV&quot;
  }, 
  &quot;origin&quot;: &quot;197.52.178.58, 197.52.178.58&quot;, 
  &quot;url&quot;: &quot;https://httpbin.org/get&quot;
}

</code></pre>
<p>This is called a Response, response consists of</p>
<ul>
<li>status line: <code>HTTPVER STATUS_CODE STATUS_MESSAGE</code> e.g <code>HTTP/1.1 200 OK</code></li>
<li>list of headers
<ul>
<li><code>Content-Type</code>: <code>application/json</code> type of content</li>
<li><code>Date</code>: <code>Mon, 21 Oct 2019 18:28:13 GMT</code> date of the response</li>
<li><code>Server</code>: nginx <code>server name</code></li>
<li><code>Content-Length</code>: 206 length of the upcoming body</li>
</ul>
</li>
</ul>
<p>Now let's go over the abstractions needed</p>
<a class="header" href="#http-version" id="http-version"><h3>Http Version</h3></a>
<p>There're multiple http specifications <code>0.9</code>, <code>1.0</code>, <code>1.1</code>, ..</p>
<p>so let's start with that. a Simple enum should be enough</p>
<pre><code class="language-nim">type
  HttpVersion* = enum
    HttpVer11,
    HttpVer10


proc `$`(ver:HttpVersion): string = 
      case ver
      of HttpVer10: result=&quot;HTTP/1.0&quot;
      of HttpVer11: result=&quot;HTTP/1.1&quot;


</code></pre>
<a class="header" href="#httpmethods" id="httpmethods"><h3>HttpMethods</h3></a>
<p>We all know <code>GET</code>, <code>POST</code>, <code>HEAD</code>, .. methods, again can be represented by a Simple enum</p>
<pre><code class="language-nim">type
  HttpMethod* = enum  ## the requested HttpMethod
    HttpHead,         ## Asks for the response identical to the one that would
                      ## correspond to a GET request, but without the response
                      ## body.
    HttpGet,          ## Retrieves the specified resource.
    HttpPost,         ## Submits data to be processed to the identified
                      ## resource. The data is included in the body of the
                      ## request.
    HttpPut,          ## Uploads a representation of the specified resource.
    HttpDelete,       ## Deletes the specified resource.
    HttpTrace,        ## Echoes back the received request, so that a client
                      ## can see what intermediate servers are adding or
                      ## changing in the request.
    HttpOptions,      ## Returns the HTTP methods that the server supports
                      ## for specified address.
    HttpConnect,      ## Converts the request connection to a transparent
                      ## TCP/IP tunnel, usually used for proxies.
    HttpPatch         ## Applies partial modifications to a resource.



proc httpMethodFromString(txt: string):  Option[HttpMethod] = 
    let s2m = {&quot;GET&quot;: HttpGet, &quot;POST&quot;: HttpPost, &quot;PUT&quot;:HttpPut, &quot;PATCH&quot;: HttpPatch, &quot;DELETE&quot;: HttpDelete, &quot;HEAD&quot;:HttpHead}.toTable
    if txt in s2m:
        result = some(s2m[txt.toUpper])
    else:
        result = none(HttpMethod)
</code></pre>
<p>Also we add <code>httpMethodFromString</code> that takes a string and returns option[HttpMethod] value.</p>
<a class="header" href="#http-code" id="http-code"><h3>Http Code</h3></a>
<p>HTTP specifications specifies certain code responses (status codes) to indicate the state for the request</p>
<ul>
<li>20X -&gt; it's fine</li>
<li>30X -&gt; redirections</li>
<li>40X -&gt; client messed up</li>
<li>50X -&gt; server messed up</li>
</ul>
<pre><code class="language-nim">
  HttpCode* = distinct range[0 .. 599]

const
  Http200* = HttpCode(200)
  Http201* = HttpCode(201)
  Http202* = HttpCode(202)
  Http203* = HttpCode(203)
  ...
  Http300* = HttpCode(300)
  Http301* = HttpCode(301)
  Http302* = HttpCode(302)
  Http303* = HttpCode(303)
  ..
  Http400* = HttpCode(400)
  Http401* = HttpCode(401)
  Http403* = HttpCode(403)
  Http404* = HttpCode(404)
  Http405* = HttpCode(405)
  Http406* = HttpCode(406)
  ...
  Http451* = HttpCode(451)
  Http500* = HttpCode(500)
  ...


proc `$`*(code: HttpCode): string =
    ## Converts the specified ``HttpCode`` into a HTTP status.
    ##
    ## For example:
    ##
    ##   .. code-block:: nim
    ##       doAssert($Http404 == &quot;404 Not Found&quot;)
    case code.int
    ..
    of 200: &quot;200 OK&quot;
    of 201: &quot;201 Created&quot;
    of 202: &quot;202 Accepted&quot;
    of 204: &quot;204 No Content&quot;
    of 205: &quot;205 Reset Content&quot;
    ...
    of 301: &quot;301 Moved Permanently&quot;
    of 302: &quot;302 Found&quot;
    of 303: &quot;303 See Other&quot;
    ..
    of 400: &quot;400 Bad Request&quot;
    of 401: &quot;401 Unauthorized&quot;
    of 403: &quot;403 Forbidden&quot;
    of 404: &quot;404 Not Found&quot;
    of 405: &quot;405 Method Not Allowed&quot;
    of 406: &quot;406 Not Acceptable&quot;
    of 408: &quot;408 Request Timeout&quot;
    of 409: &quot;409 Conflict&quot;
    of 410: &quot;410 Gone&quot;
    of 411: &quot;411 Length Required&quot;
    of 413: &quot;413 Request Entity Too Large&quot;
    of 414: &quot;414 Request-URI Too Long&quot;
    of 415: &quot;415 Unsupported Media Type&quot;
    of 416: &quot;416 Requested Range Not Satisfiable&quot;
    of 429: &quot;429 Too Many Requests&quot;
    ...
    of 500: &quot;500 Internal Server Error&quot;
    of 501: &quot;501 Not Implemented&quot;
    of 502: &quot;502 Bad Gateway&quot;
    of 503: &quot;503 Service Unavailable&quot;
    of 504: &quot;504 Gateway Timeout&quot;
    ...
    else: $(int(code))

</code></pre>
<p>the code above is taken from <code>pure/http</code> in nim stdlib</p>
<a class="header" href="#headers" id="headers"><h3>headers</h3></a>
<p>another abstraction we need is the headers list. Headers in http aren't just key=value, but key=[value] so key can has a list of values.</p>
<pre><code class="language-nim">type HttpHeaders* = ref object
      table*: TableRef[string, seq[string]]

type HttpHeaderValues* =  seq[string]

proc newHttpHeaders*(): HttpHeaders =
  new result
  result.table = newTable[string, seq[string]]()

proc newHttpHeaders*(keyValuePairs:
    seq[tuple[key: string, val: string]]): HttpHeaders =
  var pairs: seq[tuple[key: string, val: seq[string]]] = @[]
  for pair in keyValuePairs:
    pairs.add((pair.key.toLowerAscii(), @[pair.val]))
  new result
  result.table = newTable[string, seq[string]](pairs)

proc `$`*(headers: HttpHeaders): string =
  return $headers.table

proc clear*(headers: HttpHeaders) =
  headers.table.clear()

proc `[]`*(headers: HttpHeaders, key: string): HttpHeaderValues =
  ## Returns the values associated with the given ``key``. If the returned
  ## values are passed to a procedure expecting a ``string``, the first
  ## value is automatically picked. If there are
  ## no values associated with the key, an exception is raised.
  ##
  ## To access multiple values of a key, use the overloaded ``[]`` below or
  ## to get all of them access the ``table`` field directly.
  return headers.table[key.toLowerAscii].HttpHeaderValues

# converter toString*(values: HttpHeaderValues): string =
#   return seq[string](values)[0]

proc `[]`*(headers: HttpHeaders, key: string, i: int): string =
  ## Returns the ``i``'th value associated with the given key. If there are
  ## no values associated with the key or the ``i``'th value doesn't exist,
  ## an exception is raised.
  return headers.table[key.toLowerAscii][i]

proc `[]=`*(headers: HttpHeaders, key, value: string) =
  ## Sets the header entries associated with ``key`` to the specified value.
  ## Replaces any existing values.
  headers.table[key.toLowerAscii] = @[value]

proc `[]=`*(headers: HttpHeaders, key: string, value: seq[string]) =
  ## Sets the header entries associated with ``key`` to the specified list of
  ## values.
  ## Replaces any existing values.
  headers.table[key.toLowerAscii] = value

proc add*(headers: HttpHeaders, key, value: string) =
  ## Adds the specified value to the specified key. Appends to any existing
  ## values associated with the key.
  if not headers.table.hasKey(key.toLowerAscii):
    headers.table[key.toLowerAscii] = @[value]
  else:
    headers.table[key.toLowerAscii].add(value)

proc del*(headers: HttpHeaders, key: string) =
  ## Delete the header entries associated with ``key``
  headers.table.del(key.toLowerAscii)

iterator pairs*(headers: HttpHeaders): tuple[key, value: string] =
  ## Yields each key, value pair.
  for k, v in headers.table:
    for value in v:
      yield (k, value)

proc contains*(values: HttpHeaderValues, value: string): bool =
  ## Determines if ``value`` is one of the values inside ``values``. Comparison
  ## is performed without case sensitivity.
  for val in seq[string](values):
    if val.toLowerAscii == value.toLowerAscii: return true

proc hasKey*(headers: HttpHeaders, key: string): bool =
  return headers.table.hasKey(key.toLowerAscii())

proc getOrDefault*(headers: HttpHeaders, key: string,
    default = @[&quot;&quot;].HttpHeaderValues): HttpHeaderValues =
  ## Returns the values associated with the given ``key``. If there are no
  ## values associated with the key, then ``default`` is returned.
  if headers.hasKey(key):
    return headers[key]
  else:
    return default

proc len*(headers: HttpHeaders): int = return headers.table.len

proc parseList(line: string, list: var seq[string], start: int): int =
  var i = 0
  var current = &quot;&quot;
  while start+i &lt; line.len and line[start + i] notin {'\c', '\l'}:
    i += line.skipWhitespace(start + i)
    i += line.parseUntil(current, {'\c', '\l', ','}, start + i)
    list.add(current)
    if start+i &lt; line.len and line[start + i] == ',':
      i.inc # Skip ,
    current.setLen(0)

proc parseHeader*(line: string): tuple[key: string, value: seq[string]] =
  ## Parses a single raw header HTTP line into key value pairs.
  ##
  ## Used by ``asynchttpserver`` and ``httpclient`` internally and should not
  ## be used by you.
  result.value = @[]
  var i = 0
  i = line.parseUntil(result.key, ':')
  inc(i) # skip :
  if i &lt; len(line):
    i += parseList(line, result.value, i)
  elif result.key.len &gt; 0:
    result.value = @[&quot;&quot;]
  else:
    result.value = @[]
</code></pre>
<p>So we have the abstraction now over the headers. very nice.</p>
<a class="header" href="#request" id="request"><h3>Request</h3></a>
<pre><code class="language-nim">type Request = object 
  httpMethod*: HTTPMethod
  httpVersion*: HttpVersion
  headers*: HTTPHeaders
  path*: string
  body*: string
  queryParams*: TableRef[string, string]
  formData*: TableRef[string, string]
  urlParams*: TableRef[string, string]
</code></pre>
<p>request is a type that keeps track of</p>
<ul>
<li>http version: from the client request</li>
<li>request method: get, post, .. etc</li>
<li>requested path: if the url is <code>localhost:9000/users/myfile</code> the requested path would be <code>/users/myfile</code></li>
<li>headers: request headers</li>
<li>body: body</li>
<li>formData: submitted form data</li>
<li>queryParams: if the url is <code>/users/search?name=xmon&amp;age=50</code> the queryParams will be Table {&quot;name&quot;:&quot;xmon&quot;, &quot;age&quot;:50}</li>
<li>urlParams: are the captured variables by the router
if we have a route to handle <code>/users/:username/:language</code> and we received request with path <code>/users/xmon/ar</code> it will bind <code>username</code> to <code>xmon</code> and <code>language</code> to <code>ar</code> and make that available on the request object to be used later on by the handler.</li>
</ul>
<a class="header" href="#building-the-request" id="building-the-request"><h4>Building the request</h4></a>
<p>remember the <code>handleClient</code> that we mentioned in the big picture section?</p>
<pre><code class="language-nim">
proc handleClient(s: ref Servy, client: AsyncSocket) {.async.} =
  var req = await s.parseRequestFromConnection(client)
  ...
</code></pre>
<p>So let's implement <code>parseRequestFromConnection</code></p>
<pre><code class="language-nim">

proc parseRequestFromConnection(s: ref Servy, conn:AsyncSocket): Future[Request] {.async.} = 

    result.queryParams = newTable[string, string]()
    result.formData = newTable[string, string]()
    result.urlParams = newTable[string, string]()

    let requestline = $await conn.recvLine(maxLength=maxLine)
    var  meth, path, httpver: string
    var parts = requestLine.splitWhitespace()
    meth = parts[0]
    path = parts[1]
    httpver = parts[2]
    var contentLength = 0
    echo meth, path, httpver
    let m = httpMethodFromString(meth)
    if m.isSome:
        result.httpMethod = m.get()
    else:
        echo meth
        raise newException(OSError, &quot;invalid httpmethod&quot;)
    if &quot;1.1&quot; in httpver:
        result.httpVersion = HttpVer11
    elif &quot;1.0&quot; in httpver:
        result.httpVersion = HttpVer10
  
    result.path = path

    if &quot;?&quot; in path:
      # has query params
      result.queryParams = parseQueryParams(path) 
    
</code></pre>
<p>First we parse the request line <code>METHOD PATH HTTPVER</code> e.g <code>GET /users HTTP/1.1</code> so if we split on spaces we get the method, path, and http version</p>
<p>Also if there's <code>?</code> like in <code>/users?username=xmon</code> in the request path, we should parse the Query Parameters</p>
<pre><code class="language-nim">
proc parseQueryParams(content: string): TableRef[string, string] =
  result = newTable[string, string]()
  var consumed = 0
  if &quot;?&quot; notin content and &quot;=&quot; notin content:
    return
  if &quot;?&quot; in content:
    consumed += content.skipUntil({'?'}, consumed)

  inc consumed # skip ? now.

  while consumed &lt; content.len:
    if &quot;=&quot; notin content[consumed..^1]:
      break

    var key = &quot;&quot;
    var val = &quot;&quot;
    consumed += content.parseUntil(key, &quot;=&quot;, consumed)
    inc consumed # =
    consumed += content.parseUntil(val, &quot;&amp;&quot;, consumed)
    inc consumed
    # result[decodeUrl(key)] = result[decodeUrl(val)]
    result.add(decodeUrl(key), decodeUrl(val))
    echo &quot;consumed:&quot; &amp; $consumed
    echo &quot;contentlen:&quot; &amp; $content.len


</code></pre>
<p>Next should be the headers</p>
<pre><code class="language-nim">    result.headers = newHttpHeaders()


    # parse headers
    var line = &quot;&quot;
    line = $(await conn.recvLine(maxLength=maxLine))
    echo fmt&quot;line: &gt;{line}&lt; &quot;
    while line != &quot;\r\n&quot;:
      # a header line
      let kv = parseHeader(line)
      result.headers[kv.key] = kv.value
      if kv.key.toLowerAscii == &quot;content-length&quot;:
        contentLength = parseInt(kv.value[0])
      line = $(await conn.recvLine(maxLength=maxLine))
      # echo fmt&quot;line: &gt;{line}&lt; &quot;

</code></pre>
<p>We receive the headers and figure out the body length from <code>content-length</code> header to know how much to consume from the socket after we're done with the headers.</p>
<pre><code class="language-nim">    if contentLength &gt; 0:
      result.body = await conn.recv(contentLength)

    discard result.parseFormData()
</code></pre>
<p>Now that we know how much to consume (<code>contentLength</code>) from socket we can capture the request's body.
Notice that <code>parseFormData</code> handles the form submitted in the request, let's take a look at that next.</p>
<a class="header" href="#submitting-data" id="submitting-data"><h5>Submitting data.</h5></a>
<p>In HTTP there are different <code>Content-Type(s)</code> to submit (post) data: <code>application/x-www-form-urlencoded</code> and <code>multipart/form-data</code>.</p>
<p>Quoting stackoverflow <a href="https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data">answer</a></p>
<pre><code>The purpose of both of those types of requests is to send a list of name/value pairs to the server. Depending on the type and amount of data being transmitted, one of the methods will be more efficient than the other. To understand why, you have to look at what each is doing under the covers.

For application/x-www-form-urlencoded, the body of the HTTP message sent to the server is essentially one giant query string -- name/value pairs are separated by the ampersand (&amp;), and names are separated from values by the equals symbol (=). An example of this would be: 

MyVariableOne=ValueOne&amp;MyVariableTwo=ValueTwo


That means that for each non-alphanumeric byte that exists in one of our values, it's going to take three bytes to represent it. For large binary files, tripling the payload is going to be highly inefficient.

That's where multipart/form-data comes in. With this method of transmitting name/value pairs, each pair is represented as a &quot;part&quot; in a MIME message (as described by other answers). Parts are separated by a particular string boundary (chosen specifically so that this boundary string does not occur in any of the &quot;value&quot; payloads). Each part has its own set of MIME headers like Content-Type, and particularly Content-Disposition, which can give each part its &quot;name.&quot; The value piece of each name/value pair is the payload of each part of the MIME message. The MIME spec gives us more options when representing the value payload -- we can choose a more efficient encoding of binary data to save bandwidth (e.g. base 64 or even raw binary).
</code></pre>
<p>e.g:</p>
<p>If you want to send the following data to the web server:</p>
<pre><code>name = John
age = 12
</code></pre>
<p>using <code>application/x-www-form-urlencoded</code> would be like this:</p>
<pre><code>name=John&amp;age=12
</code></pre>
<p>As you can see, the server knows that parameters are separated by an ampersand &amp;. If &amp; is required for a parameter value then it must be encoded.</p>
<p>So how does the server know where a parameter value starts and ends when it receives an HTTP request using multipart/form-data?</p>
<p>Using the boundary, similar to &amp;.</p>
<p>For example:</p>
<pre><code>--XXX
Content-Disposition: form-data; name=&quot;name&quot;

John
--XXX
Content-Disposition: form-data; name=&quot;age&quot;

12
--XXX--
</code></pre>
<p><a href="https://stackoverflow.com/questions/3508338/what-is-the-boundary-in-multipart-form-data">reference</a> of the above explanation</p>
<pre><code class="language-nim">
type FormPart = object
      name*: string
      headers*: HttpHeaders
      body*: string

proc newFormPart(): ref FormPart = 
  new result
  result.headers = newHttpHeaders()

proc `$`(this:ref FormPart): string = 
  result = fmt&quot;partname: {this.name} partheaders: {this.headers} partbody: {this.body}&quot; 

type FormMultiPart = object
  parts*: TableRef[string, ref FormPart]

proc newFormMultiPart(): ref FormMultiPart = 
  new result
  result.parts = newTable[string, ref FormPart]()

proc `$`(this: ref FormMultiPart): string = 
  return fmt&quot;parts: {this.parts}&quot;
</code></pre>
<p>So that's our abstraction for multipart form.</p>
<pre><code>proc parseFormData(r: Request): ref FormMultiPart =


  discard &quot;&quot;&quot;
received request from client: (httpMethod: HttpPost, requestURI: &quot;&quot;, httpVersion: HTTP/1.1, headers: {&quot;accept&quot;: @[&quot;*/*&quot;], &quot;content-length&quot;: @[&quot;241&quot;], &quot;content-type&quot;: @[&quot;multipart/form-data; boundary=------------------------95909933ebe184f2&quot;], &quot;host&quot;: @[&quot;127.0.0.1:9000&quot;], &quot;user-agent&quot;: @[&quot;curl/7.62.0-DEV&quot;]}, path: &quot;/post&quot;, body: &quot;--------------------------95909933ebe184f2\c\nContent-Disposition: form-data; name=\&quot;who\&quot;\c\n\c\nhamada\c\n--------------------------95909933ebe184f2\c\nContent-Disposition: form-data; name=\&quot;next\&quot;\c\n\c\nhome\c\n--------------------------95909933ebe184f2--\c\n&quot;, raw_body: &quot;&quot;, queryParams: {:})
  &quot;&quot;&quot;

  result = newFormMultiPart()
  
  let contenttype = r.headers.getOrDefault(&quot;content-type&quot;)[0]
  let body = r.body
  
  if &quot;form-urlencoded&quot; in contenttype.toLowerAscii():
    # query params are the post body
    let postBodyAsParams = parseQueryParams(body)
    for k, v in postBodyAsParams.pairs:
      r.queryParams.add(k, v)     

</code></pre>
<p>if the content-type has the word <code>form-urlencoded</code> we parse he body as if it was queryParams</p>
<pre><code class="language-nim">
  elif contenttype.startsWith(&quot;multipart/&quot;) and &quot;boundary&quot; in contenttype:
    var boundaryName = contenttype[contenttype.find(&quot;boundary=&quot;)+&quot;boundary=&quot;.len..^1]
    echo &quot;boundayName: &quot; &amp; boundaryName
    for partString in body.split(boundaryName &amp; &quot;\c\L&quot;):
      var part = newFormPart()
      var partName = &quot;&quot;

      var totalParsedLines = 1
      let bodyLines = body.split(&quot;\c\L&quot;)[1..^1] # at the boundary line
      for line in bodyLines:
        if line.strip().len != 0:
          let splitted = line.split(&quot;: &quot;)
          if len(splitted) == 2:
            part.headers.add(splitted[0], splitted[1])
          elif len(splitted) == 1:
            part.headers.add(splitted[0], &quot;&quot;)
          
          if &quot;content-disposition&quot; in line.toLowerAscii and &quot;name&quot; in line.toLowerAscii:
            # Content-Disposition: form-data; name=&quot;next&quot;
            var consumed = line.find(&quot;name=&quot;)+&quot;name=&quot;.len
            discard line.skip(&quot;\&quot;&quot;, consumed) 
            inc consumed
            consumed += line.parseUntil(partName, &quot;\&quot;&quot;, consumed)

        else:
          break # done with headers now for the body.

        inc totalParsedLines
      
      let content = join(bodyLines[totalParsedLines..^1], &quot;\c\L&quot;)
      part.body = content
      part.name = partName
      result.parts.add(partName, part)
      echo $result.parts

</code></pre>
<p>if it's not <code>form-urlencoded</code> then it's a multipart then we need to figure out the boundary and split the body on that boundary text</p>
<a class="header" href="#response" id="response"><h3>Response</h3></a>
<p>Now that we can parse the client request we need to be able to build a correctly formatted response.
Response keeps track of</p>
<ul>
<li>http version</li>
<li>response status code</li>
<li>response content</li>
<li>response headers</li>
</ul>
<pre><code class="language-nim">type Response = object
  headers: HttpHeaders
  httpver: HttpVersion
  code: HttpCode
  content: string
</code></pre>
<a class="header" href="#formatting-response" id="formatting-response"><h4>Formatting response</h4></a>
<pre><code class="language-nim">
proc formatStatusLine(code: HttpCode, httpver: HttpVersion) : string =
  return fmt&quot;{httpver} {code}&quot; &amp; &quot;\r\n&quot;

</code></pre>
<p>Here we build status line which is <code>HTTPVERSION STATUS_CODE STATUS_MSG\r\n</code> e.g <code>HTTP/1.1 200 OK</code></p>
<pre><code class="language-nim">proc formatResponse(code:HttpCode, httpver:HttpVersion, content:string, headers:HttpHeaders): string = 
  result &amp;= formatStatusLine(code, httpver)
  if headers.len &gt; 0:
    for k,v in headers.pairs:
      result &amp;= fmt&quot;{k}: {v}&quot; &amp; &quot;\r\n&quot;
  result &amp;= fmt&quot;Content-Length: {content.len}&quot; &amp; &quot;\r\n\r\n&quot;
  result &amp;= content
  echo &quot;will send&quot;
  echo result
  

proc format(resp: ref Response) : string = 
  result = formatResponse(resp.code, resp.httpver, resp.content, resp.headers)


</code></pre>
<p>To format a complete response we need</p>
<ul>
<li>building status line</li>
<li>headers to string</li>
<li>content length to be the length for the body</li>
<li>the body itself</li>
</ul>
<a class="header" href="#handling-client-request" id="handling-client-request"><h3>Handling client request</h3></a>
<p>so every handler function should take a <code>Request</code> object and return a Response to be sent on the wire. Right?</p>
<pre><code class="language-nim">

proc handleClient(s: ref Servy, client: AsyncSocket) {.async.} =
  var req = await s.parseRequestFromConnection(client)
  ...
  let (routeHandler, params) = s.router.getByPath(req.path)
  req.urlParams = params
  let handler = routeHandler.handlerFunc
  ...
  let resp = handler(req)
  await client.send(resp.format())

</code></pre>
<p>Very cool the router will magically return to us a suitable route handler or 404 handler if not found using its <code>getByPath</code> proc</p>
<ul>
<li>We get the handler</li>
<li>apply it to the request to get a valid http response</li>
<li>send the response to the client on the wire.</li>
</ul>
<p>Let's get to the Handler Function example definition again</p>
<pre><code class="language-nim">
    proc handleHello(req:var Request): ref Response =
      result = newResponse()
      result.code = Http200
      result.content = &quot;hello world from handler /hello&quot; &amp; $req 
</code></pre>
<p>so it takes a request and returns a response, how about we create an alias for that?</p>
<pre><code class="language-nim">type HandlerFunc = proc(req: var Request):ref Response {.nimcall.}
</code></pre>
<a class="header" href="#middlewares" id="middlewares"><h3>Middlewares</h3></a>
<p>It's typical in many frameworks to apply certain set of checks or functions on the incoming request before sending it to any handler, like logging the request first, or trimming the trailing slashes, or checking for a certain header</p>
<p>How can we implement that? Remember our <code>handleClient</code>? they need to be applied before the request reach the handler so should be above <code>handler(req)</code></p>
<pre><code class="language-nim">
proc handleClient(s: ref Servy, client: AsyncSocket) {.async.} =
  var req = await s.parseRequestFromConnection(client)
  ### HERE SHOULD BE MIDDLEWARE Code
  ###
  ###


  let (routeHandler, params) = s.router.getByPath(req.path)
  req.urlParams = params
  let handler = routeHandler.handlerFunc
  ...
  let resp = handler(req)
  await client.send(resp.format())
</code></pre>
<p>So let's get to the implementation</p>
<pre><code class="language-nim">
proc handleClient(s: ref Servy, client: AsyncSocket) {.async.} =
  var req = await s.parseRequestFromConnection(client)
  
  for  m in s.middlewares:
    let (resp, usenextmiddleware) = m(req)
    if not usenextmiddleware:
      echo &quot;early return from middleware...&quot;
      await client.send(resp.format())
      return
  ...
  let handler = routeHandler.handlerFunc
  ...
  let resp = handler(req)
  await client.send(resp.format())

</code></pre>
<p>here we loop over all registered middlewares</p>
<ul>
<li>middleware should return a response to be sent if it needs to terminate the handling immediately</li>
<li>should tell us if we should continue applying middlewares or terminate immediately</li>
</ul>
<p>That's why the definition of a middleware is like that</p>
<pre><code class="language-nim">
    let loggingMiddleware = proc(request: var Request): (ref Response, bool) =
      let path = request.path
      let headers = request.headers
      echo &quot;===============================&quot;
      echo &quot;from logger handler&quot;
      echo &quot;path: &quot; &amp; path
      echo &quot;headers: &quot; &amp; $headers
      echo &quot;===============================&quot;
      return (newResponse(), true)

</code></pre>
<p>Let's create an alias for middleware function so we can use it easily in the rest of our code</p>
<pre><code class="language-nim">type MiddlewareFunc = proc(req: var Request): (ref Response, bool) {.nimcall.}
</code></pre>
<a class="header" href="#route-specific-middlewares" id="route-specific-middlewares"><h4>Route specific middlewares</h4></a>
<p>above we talked about global application middlewares, but maybe we want to apply some middleware or <code>filter</code> to a certain route</p>
<pre><code class="language-nim">
proc handleClient(s: ref Servy, client: AsyncSocket) {.async.} =
  var req = await s.parseRequestFromConnection(client)
  
  
  for  m in s.middlewares:
    let (resp, usenextmiddleware) = m(req)
    if not usenextmiddleware:
      echo &quot;early return from middleware...&quot;
      await client.send(resp.format())
      return

  echo &quot;received request from client: &quot; &amp; $req

  let (routeHandler, params) = s.router.getByPath(req.path)
  req.urlParams = params
  let handler = routeHandler.handlerFunc
  let middlewares = routeHandler.middlewares
  
  

  for  m in middlewares:
    let (resp, usenextmiddleware) = m(req)
    if not usenextmiddleware:
      echo &quot;early return from route middleware...&quot;
      await client.send(resp.format())
      return
    
  let resp = handler(req)
  echo &quot;reached the handler safely.. and executing now.&quot;
  await client.send(resp.format())
  echo $req.formData


</code></pre>
<p>notice now we have a route specific middlewares to apply as well before calling <code>handler(req)</code> maybe to check for a header before allowing access on that route.</p>
<a class="header" href="#router" id="router"><h3>Router</h3></a>
<p>Router is one of the essential components in our code it's responsible to keep track of what the registered pattern and their handlers so we can actually do something with incoming request and the filters <code>middlewares</code> to apply on the request</p>
<pre><code class="language-nim">
type RouterValue = object
  handlerFunc: HandlerFunc
  middlewares:seq[MiddlewareFunc]

type Router = object
  table: TableRef[string, RouterValue]

</code></pre>
<p>Basic definition of the router as it's a map from a <code>url pattern</code> to <code>RouterValue</code> that basically has a reference to the handler proc and a sequence of middlewares/filters</p>
<pre><code class="language-nim">proc newRouter(): ref Router =
  result = new Router
  result.table = newTable[string, RouterValue]()
</code></pre>
<p>Initializing the router</p>
<pre><code class="language-nim">proc handle404(req: var Request): ref Response  = 
  var resp = newResponse()
  resp.code = Http404
  resp.content = fmt&quot;nothing at {req.path}&quot;
  return resp
</code></pre>
<p>Simple 404 handler in case that we don't find a handler for the requested path</p>
<pre><code class="language-nim">proc getByPath(r: ref Router, path: string, notFoundHandler:HandlerFunc=handle404) : (RouterValue, TableRef[string, string]) =
  var found = false
  if path in r.table: # exact match
    return (r.table[path], newTable[string, string]())

  for handlerPath, routerValue in r.table.pairs:
    echo fmt&quot;checking handler:  {handlerPath} if it matches {path}&quot; 
    let pathParts = path.split({'/'})
    let handlerPathParts = handlerPath.split({'/'})
    echo fmt&quot;pathParts {pathParts} and handlerPathParts {handlerPathParts}&quot;

    if len(pathParts) != len(handlerPathParts):
      echo &quot;length isn't ok&quot;
      continue
    else:
      var idx = 0
      var capturedParams = newTable[string, string]()

      while idx&lt;len(pathParts):
        let pathPart = pathParts[idx]
        let handlerPathPart = handlerPathParts[idx]
        echo fmt&quot;current pathPart {pathPart} current handlerPathPart: {handlerPathPart}&quot;

        if handlerPathPart.startsWith(&quot;:&quot;) or handlerPathPart.startsWith(&quot;@&quot;):
          echo fmt&quot;found var in path {handlerPathPart} matches {pathPart}&quot;
          capturedParams[handlerPathPart[1..^1]] = pathPart
          inc idx
        else:
          if pathPart == handlerPathPart:
            inc idx
          else:
            break

        if idx == len(pathParts):
          found = true
          return (routerValue, capturedParams)

  if not found:
    return (RouterValue(handlerFunc:notFoundHandler, middlewares: @[]), newTable[string, string]())
</code></pre>
<p>Here we search for pattern registered in the router for exact match or if it has varialbes we and capture their values
e.g: <code>/users/:name/:lang</code> pattern matches the request <code>/users/xmon/ar</code> and creates env <code>Table</code> with <code>{&quot;name&quot;:&quot;xmon&quot;, &quot;lang&quot;:&quot;ar&quot;}</code></p>
<ul>
<li><code>/mywebsite/homepage</code> pattern matches /mywebsite/homepage</li>
<li><code>/blogs/:username</code> pattern<code>matches the path</code>/blogs/xmon<code>and</code>/blogs/ahmed<code>so it capture the env with variable name</code>username<code>and variable value</code>xmon<code>or</code>ahmed` and returns</li>
<li>when we found the suitable handler and its env we set the env on the request on <code>urlParams</code> field and call the handler on the updated request.
Remember our <code>handleClient</code> proc?</li>
</ul>
<pre><code class="language-nim">
proc handleClient(s: ref Servy, client: AsyncSocket) {.async.} =
  var req = await s.parseRequestFromConnection(client)
  
  ## Global middlewares
  ## ..
  ## ..

  let (routeHandler, params) = s.router.getByPath(req.path)
  req.urlParams = params
  let handler = routeHandler.handlerFunc

  ## Route middlewares.
  ## ..
  ## ..
  let resp = handler(req)
  await client.send(resp.format())

</code></pre>
<pre><code class="language-nim">proc addHandler(router: ref Router, route: string, handler: HandlerFunc, httpMethod:HttpMethod=HttpGet, middlewares:seq[MiddlewareFunc]= @[]) = 
  router.table.add(route, RouterValue(handlerFunc:handler, middlewares:middlewares))

</code></pre>
<p>we provide a simple function to add a handler to a route setting the method type and the middlewares as well on a <code>Router</code> object.</p>
<a class="header" href="#whats-next-1" id="whats-next-1"><h2>What's next?</h2></a>
<p>We didn't talk about templates, cookies, sessions, dates, sending files and for sure that's not a complete <a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">HTTP ref</a> implementation by any means. <a href="https://github.com/dom96/jester">Jester</a> is a great option to check.
Thank you for going through this day and please feel free to send PR or open issue on <a href="https://github.com/xmonader/nim-servy/">nim-servy</a> repository</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
